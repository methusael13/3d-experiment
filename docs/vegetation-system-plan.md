# Vegetation System Implementation Plan

This document outlines the design and implementation plan for a GPU-based vegetation system that covers terrain with biome-appropriate plants, starting with grassland biomes.

## Overview

The vegetation system renders plants (grass, shrubs, flowers, ferns, trees) across terrain surfaces using a **hybrid rendering approach**:
- **3D mesh instances** for close/medium range ‚Äî full geometry from GLTF models
- **Billboard instances** for far range ‚Äî camera-facing quads from atlas or billboard textures
- **Automatic LOD transitions** between 3D and billboard based on distance

Vegetation density is driven by:
- **Biome mask** ‚Äî Which biome types are present at each location
- **Water flow map** ‚Äî From hydraulic erosion, identifies fertile valleys
- **Terrain slope** ‚Äî Steep slopes get less vegetation
- **Distance-based LOD** ‚Äî Fewer instances at greater distances, 3D‚Üíbillboard transition

## Architecture

```
src/core/vegetation/
‚îú‚îÄ‚îÄ index.ts                   # Public exports
‚îú‚îÄ‚îÄ types.ts                   # Shared interfaces (PlantType, ModelReference, etc.)
‚îú‚îÄ‚îÄ VegetationManager.ts       # High-level orchestration
‚îú‚îÄ‚îÄ BiomeMaskGenerator.ts      # GPU compute for biome masks
‚îú‚îÄ‚îÄ VegetationSpawner.ts       # GPU compute for position generation
‚îú‚îÄ‚îÄ VegetationRenderer.ts      # Orchestrates billboard + mesh rendering
‚îú‚îÄ‚îÄ VegetationBillboardRenderer.ts  # Instanced billboard quad rendering
‚îú‚îÄ‚îÄ VegetationMeshRenderer.ts  # Instanced 3D mesh rendering
‚îú‚îÄ‚îÄ VegetationTileCache.ts     # Per-tile instance caching
‚îú‚îÄ‚îÄ PlantRegistry.ts           # Plant type definitions + model/atlas references
‚îî‚îÄ‚îÄ AtlasRegionDetector.ts     # Auto-detect sprite regions from opacity maps

src/core/gpu/shaders/vegetation/
‚îú‚îÄ‚îÄ biome-mask.wgsl            # Biome probability computation
‚îú‚îÄ‚îÄ spawn.wgsl                 # Instance position generation
‚îú‚îÄ‚îÄ billboard.wgsl             # Billboard vertex/fragment
‚îî‚îÄ‚îÄ vegetation-mesh.wgsl       # 3D mesh instanced vertex/fragment
```

---

## Phase 0: Water Flow Map Enhancement [Complete]

**Goal:** Track water flow during hydraulic erosion to identify fertile areas.

### Implementation Summary

Flow accumulation is tracked during hydraulic erosion by atomically incrementing a counter for each texel visited by a water droplet. After erosion completes, a finalize pass normalizes the raw counts into a 0-1 float texture using log-scale mapping.

### Key Implementation Details

**In `hydraulic-erosion.wgsl`:**
- `@group(0) @binding(4) var<storage, read_write> flowAccumulation: array<atomic<u32>>` ‚Äî atomic buffer for droplet visit tracking
- `atomicAdd(&flowAccumulation[flowIdx], 1u)` ‚Äî called in `simulateDroplets` for each droplet step
- `finalizeFlowMap` entry point ‚Äî reads atomic buffer, applies `log(1 + raw * 0.01) / log(100)` normalization, writes to `flowMapOut` texture

**In `ErosionSimulator.ts`:**
- `flowAccumulationBuffer: UnifiedGPUBuffer` ‚Äî atomic u32 per texel
- `flowMapTexture: UnifiedGPUTexture` ‚Äî r32float output texture
- `flowFinalizePipeline: ComputePipelineWrapper` ‚Äî pipeline for finalize pass
- Flow buffer cleared at start of each erosion session via `clearBuffer()`
- `getFlowMap()` accessor returns the normalized texture

**In `TerrainManager.ts`:**
- `flowMap` field cached from `erosionSimulator.getFlowMap()`
- `getFlowMap()` public accessor for vegetation system

### Tasks
- [x] Add `flowAccumulation` atomic buffer binding to hydraulic-erosion.wgsl
- [x] Track droplet visits with `atomicAdd` during simulation
- [x] Add `finalizeFlowMap` entry point
- [x] Update ErosionSimulator with flow buffer + texture
- [x] Add flow finalize pipeline and bind group
- [x] Clear flow buffer at erosion start
- [x] Add `getFlowMap()` accessor to ErosionSimulator
- [x] Update TerrainManager to store and expose flow map
- [x] Flow map available for debug display via DebugTextureManager

---

## Phase 1: Biome Mask Generation [Complete]

**Goal:** Generate RGBA texture encoding biome probabilities from terrain data.

### Biome Channels
| Channel | Biome | Conditions |
|---------|-------|------------|
| R | Grassland | Moderate height, low slope, optimal flow |
| G | Rock/Cliff | High slope or very high altitude |
| B | Forest Edge | Moderate height, low slope, good water flow |
| A | Reserved (1.0) | Future (snow, desert, etc.) |

### Implementation Summary

The biome mask is generated by a GPU compute shader that samples the heightmap, calculates slope from neighboring texels, and samples the optional flow map. Each biome channel is computed independently with smoothstep transitions.

**`BiomeParams` interface (13 fields):**
```typescript
export interface BiomeParams {
  heightInfluence: number;      // Weight for height factor
  slopeInfluence: number;       // Weight for slope factor
  flowInfluence: number;        // Weight for flow factor
  seed: number;                 // Noise variation seed
  
  grassHeightMin: number;       // Min height for grassland
  grassHeightMax: number;       // Max height for grassland
  grassSlopeMax: number;        // Max slope for grassland
  rockSlopeMin: number;         // Min slope for rock appearance
  
  forestFlowMin: number;        // Min flow for forest
  forestFlowMax: number;        // Max flow (above = flooded)
  forestHeightMin: number;      // Min height for forest
  forestHeightMax: number;      // Max height for forest
  
  defaultFlowValue: number;     // Default flow when no flow map (0-1)
}
```

**GPU struct (`biome-mask.wgsl`):** 64-byte uniform (16 floats with 3 padding).

**Key differences from original plan:**
- BiomeParams expanded from 8 to 13 fields (added forestFlowMin/Max, forestHeightMin/Max, defaultFlowValue)
- Slope calculation uses `saturate(slope * 25.0)` normalization for the terrain's -0.5 to 0.5 height range
- Rock probability considers both steep slopes AND high altitude
- Forest uses weighted `min(heightFactor, slopeFactor) * (0.3 + 0.7 * flowFactor)` instead of simple multiplication
- Rock overrides other biomes: `grassFinal = grassland * (1.0 - rock * 0.7)`

**Dockable BiomeMask Editor UI:**
- `BiomeMaskContent.tsx` ‚Äî preview + parameter sliders in a DockableWindow
- `BiomeMaskPanelBridge.tsx` ‚Äî connects UI to TerrainManager
- Triggered from the terrain panel

### Files
```
src/core/vegetation/BiomeMaskGenerator.ts     # Full compute pipeline with generate(), setParams()
src/core/gpu/shaders/vegetation/biome-mask.wgsl  # Compute shader with detailed documentation
src/demos/sceneBuilder/components/panels/BiomeMaskPanel/BiomeMaskContent.tsx
src/demos/sceneBuilder/components/panels/BiomeMaskPanel/BiomeMaskContent.module.css
src/demos/sceneBuilder/components/panels/BiomeMaskPanel/index.ts
src/demos/sceneBuilder/components/bridges/BiomeMaskPanelBridge.tsx
```

### Tasks
- [x] Create `biome-mask.wgsl` compute shader
- [x] Implement `BiomeMaskGenerator.ts` class
- [x] Add biome params interface and defaults (expanded to 13 fields)
- [x] Sample heightmap for height values
- [x] Calculate slope from heightmap gradients
- [x] Sample flow map (with fallback via dummy 1x1 texture if null)
- [x] Output RGBA biome probabilities
- [x] Integrate with TerrainManager (generateBiomeMask, getBiomeMask, setBiomeParams)
- [x] Create a docking window via the docking window manager to live tweak the biome mask
  - [x] The panel has a biome mask preview on the top
  - [x] Below the preview, shader uniform controls to control the biome mask
  - [x] Each biome represented by different colors
  - [x] Tweaking controls provides live feedback on the texture
- [x] This docking window triggered from the terrain panel

---

## Phase 2: Plant Foundation [Complete]

**Goal:** Define plant types and create the registry with UI controls, including 3D model support.

### Implementation Summary

This phase was extended beyond the original plan to include a **dynamic UI** for managing plant types, atlas detection, asset selection, and **3D model support with hybrid rendering modes**:

1. **PlantRegistry.ts** ‚Äî Dynamic registry with CRUD operations, event system, serialization, `setPlantModel()` for 3D model association
2. **AtlasRegionDetector.ts** ‚Äî Connected component analysis to auto-detect sprite regions from opacity maps
3. **VegetationContent.tsx** ‚Äî UI panel with biome tabs, plant property editors, **model picker**, **render mode selector** (billboard/mesh/hybrid), and **billboard distance slider**
4. **AssetPickerModal** ‚Äî Reusable modal for selecting textures and 3D models from the Asset Library
5. **VegetationPanelBridge** ‚Äî Opens vegetation editor in a DockableWindow
6. **ModelReference** type ‚Äî References GLTF models with auto-detected billboard textures

### `PlantType` Interface (Current)

```typescript
export interface PlantType {
  id: string;
  name: string;
  
  // Visual
  color: [number, number, number];       // Fallback color when no texture
  atlasRef: AtlasReference | null;       // Texture atlas reference
  atlasRegionIndex: number | null;       // Specific region in atlas
  
  // Rendering mode
  renderMode: 'billboard' | 'mesh' | 'hybrid';  // How to render this plant
  modelRef: ModelReference | null;       // 3D model reference (for mesh/hybrid)
  billboardDistance: number;             // Distance for 3D‚Üíbillboard transition (hybrid mode)
  
  // Size in world units
  minSize: [number, number];
  maxSize: [number, number];
  
  // Spawn distribution
  spawnProbability: number;
  biomeChannel: BiomeChannel;
  biomeThreshold: number;
  
  // Clustering
  clusterStrength: number;
  minSpacing: number;
  
  // LOD
  maxDistance: number;
  lodBias: number;
}
```

### `ModelReference` Interface (New)

```typescript
/**
 * Reference to a 3D vegetation model from the Asset Library.
 */
export interface ModelReference {
  /** Asset ID from the Asset Library */
  assetId: string;
  /** Asset name for display */
  assetName: string;
  /** Path to the standard (non-UE) GLTF file */
  modelPath: string;
  /** Path to billboard BaseColor+Opacity texture (auto-billboard for hybrid mode) */
  billboardTexturePath: string | null;
  /** Path to billboard Normal+Translucency texture */
  billboardNormalPath: string | null;
  /** Number of mesh variants (from GLTF sub-meshes or multiple files) */
  variantCount: number;
}
```

### `AtlasReference` Interface (Current)

```typescript
export interface AtlasReference {
  assetId: string;
  assetName: string;
  opacityPath: string;
  baseColorPath: string;
  atlasSize: [number, number];
  regions: AtlasRegion[];
}
```

### Files Created
```
src/core/vegetation/
‚îú‚îÄ‚îÄ types.ts                    # PlantType, AtlasRegion, BiomePlantConfig, VegetationConfig, WindParams, ModelReference
‚îú‚îÄ‚îÄ PlantRegistry.ts            # Dynamic registry with events, CRUD, serialization
‚îî‚îÄ‚îÄ AtlasRegionDetector.ts      # Connected component analysis for atlas regions

src/demos/sceneBuilder/components/
‚îú‚îÄ‚îÄ ui/AssetPickerModal/        # Modal for asset selection
‚îÇ   ‚îú‚îÄ‚îÄ AssetPickerModal.tsx
‚îÇ   ‚îú‚îÄ‚îÄ AssetPickerModal.module.css
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ panels/VegetationPanel/     # Plant registry editor UI
‚îÇ   ‚îú‚îÄ‚îÄ VegetationContent.tsx
‚îÇ   ‚îú‚îÄ‚îÄ VegetationContent.module.css
‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îî‚îÄ‚îÄ bridges/
    ‚îî‚îÄ‚îÄ VegetationPanelBridge.tsx
```

### Default Plant Presets

```typescript
export const GRASSLAND_PLANT_PRESETS: PlantType[] = [
  // Tall Grass, Short Grass Clump, Yellow Wildflower, Purple Wildflower, Small Shrub
  // All with renderMode: 'billboard' initially
];

export const FOREST_PLANT_PRESETS: PlantType[] = [
  // Fern, Forest Grass
  // All with renderMode: 'billboard' initially
];
```

### Tasks
- [x] Create `types.ts` (PlantType, AtlasRegion, BiomePlantConfig, VegetationConfig, WindParams)
- [x] Create `PlantRegistry.ts` (dynamic registry with events)
- [x] Define initial grassland plant presets (GRASSLAND_PLANT_PRESETS, FOREST_PLANT_PRESETS)
- [x] Add atlas region injection (setPlantAtlas method)
- [x] Create `AtlasRegionDetector.ts` (auto-detect sprite regions from opacity maps)
- [x] Create `VegetationContent.tsx` (UI panel with biome tabs)
- [x] Create `AssetPickerModal` (reusable asset selection modal)
- [x] Create `VegetationPanelBridge` (opens vegetation editor in DockableWindow)
- [x] Integrate PlantRegistry into TerrainManager
- [x] Add `ModelReference` type and `renderMode` field to PlantType
- [x] Add `modelRef` and `billboardDistance` fields to PlantType
- [x] Update `createDefaultPlantType()` with new fields
- [x] Add `setPlantModel()` method to PlantRegistry
- [x] Update VegetationContent.tsx to show model picker button alongside atlas picker
- [x] Add render mode selector (billboard/mesh/hybrid) to plant editor UI
- [x] Add billboardDistance slider for hybrid mode

---

## Phase 3: Spawning System

**Goal:** GPU compute shader generates instance positions per terrain tile.

### `spawn.wgsl`

```wgsl
struct SpawnParams {
  tileOrigin: vec2f,        // World-space tile origin
  tileSize: f32,            // World-space tile size
  density: f32,             // Instances per square unit
  lodLevel: u32,            // Current LOD level
  plantTypeIndex: u32,      // Which plant type
  biomeChannel: u32,        // 0=R, 1=G, 2=B, 3=A
  biomeThreshold: f32,      // Minimum biome value
  seed: f32,                // Random seed
  cameraPos: vec3f,         // For distance culling
  maxDistance: f32,          // Max spawn distance
  billboardDistance: f32,    // Distance threshold for 3D‚Üíbillboard transition
  renderMode: u32,          // 0=billboard, 1=mesh, 2=hybrid
  variantCount: u32,        // Number of mesh/atlas variants
  _padding: f32,
}

struct PlantInstance {
  positionAndScale: vec4f,  // xyz = world pos, w = uniform scale
  rotationAndType: vec4f,   // x = Y rotation, y = variant index, z = render flag (0=billboard, 1=mesh), w = reserved
}

@group(0) @binding(0) var<uniform> params: SpawnParams;
@group(0) @binding(1) var biomeMask: texture_2d<f32>;
@group(0) @binding(2) var heightmap: texture_2d<f32>;
@group(0) @binding(3) var<storage, read_write> instances: array<PlantInstance>;
@group(0) @binding(4) var<storage, read_write> instanceCount: atomic<u32>;
@group(0) @binding(5) var<storage, read_write> meshInstanceCount: atomic<u32>;
@group(0) @binding(6) var<storage, read_write> billboardInstanceCount: atomic<u32>;

fn hash(p: vec2f) -> f32 {
  let h = dot(p, vec2f(127.1, 311.7));
  return fract(sin(h) * 43758.5453);
}

@compute @workgroup_size(8, 8)
fn main(@builtin(global_invocation_id) gid: vec3u) {
  // Grid-based spawning within tile
  let gridSize = u32(ceil(params.tileSize * sqrt(params.density)));
  if (gid.x >= gridSize || gid.y >= gridSize) { return; }
  
  let cellSize = params.tileSize / f32(gridSize);
  let cellOrigin = params.tileOrigin + vec2f(gid.xy) * cellSize;
  
  // Deterministic jitter within cell
  let jitterSeed = cellOrigin + vec2f(params.seed);
  let jitter = vec2f(hash(jitterSeed), hash(jitterSeed + vec2f(1.0, 0.0)));
  let worldPos2D = cellOrigin + jitter * cellSize;
  
  // Sample biome mask
  let uv = worldPosToUV(worldPos2D);
  let biome = textureLoad(biomeMask, uvToTexel(uv), 0);
  let biomeValue = selectChannel(biome, params.biomeChannel);
  
  // Skip if below threshold
  if (biomeValue < params.biomeThreshold) { return; }
  
  // Distance-based probability
  let terrainHeight = textureLoad(heightmap, uvToTexel(uv), 0).r * heightScale;
  let worldPos = vec3f(worldPos2D.x, terrainHeight, worldPos2D.y);
  let dist = distance(worldPos, params.cameraPos);
  
  if (dist > params.maxDistance) { return; }
  
  // LOD-based density reduction
  let lodDensity = 1.0 / f32(1u << params.lodLevel);
  let spawnChance = biomeValue * lodDensity;
  
  if (hash(cellOrigin * 17.3 + params.seed) > spawnChance) { return; }
  
  // Determine render mode for this instance
  var renderFlag = 0.0; // 0 = billboard
  if (params.renderMode == 1u) {
    // mesh-only mode
    renderFlag = 1.0;
  } else if (params.renderMode == 2u) {
    // hybrid mode: mesh if close, billboard if far
    renderFlag = select(0.0, 1.0, dist < params.billboardDistance);
  }
  
  // Variant selection (deterministic per-cell)
  let variantIndex = f32(u32(hash(cellOrigin * 41.7 + params.seed) * f32(params.variantCount)));
  
  // Emit instance
  let idx = atomicAdd(&instanceCount, 1u);
  let scale = mix(minSize, maxSize, hash(cellOrigin * 23.7));
  let rotation = hash(cellOrigin * 31.1) * 6.28318;
  
  instances[idx].positionAndScale = vec4f(worldPos, scale);
  instances[idx].rotationAndType = vec4f(rotation, variantIndex, renderFlag, 0.0);
  
  // Track counts per render type for draw calls
  if (renderFlag > 0.5) {
    atomicAdd(&meshInstanceCount, 1u);
  } else {
    atomicAdd(&billboardInstanceCount, 1u);
  }
}
```

### `VegetationSpawner.ts`

```typescript
export interface SpawnRequest {
  tileId: string;
  tileOrigin: vec2;
  tileSize: number;
  lodLevel: number;
  cameraPosition: vec3;
}

export interface SpawnResult {
  buffer: GPUBuffer;
  totalCount: number;
  meshCount: number;
  billboardCount: number;
}

export class VegetationSpawner {
  constructor(ctx: GPUContext, plantRegistry: PlantRegistry);
  
  // Spawn vegetation for a tile, returns instance buffer
  spawnTile(
    request: SpawnRequest,
    biomeMask: UnifiedGPUTexture,
    heightmap: UnifiedGPUTexture
  ): Promise<SpawnResult>;
  
  // Batch spawn multiple tiles
  spawnTiles(requests: SpawnRequest[], ...): Promise<Map<string, SpawnResult>>;
}
```

### Tasks
- [ ] Create `spawn.wgsl` compute shader
- [ ] Implement grid-based spawning with jitter
- [ ] Sample biome mask for spawn probability
- [ ] Calculate terrain height for Y positioning
- [ ] Apply LOD-based density reduction
- [ ] Use atomic counter for instance count
- [ ] Add render flag per-instance (0=billboard, 1=mesh) based on distance and renderMode
- [ ] Add variant index selection via deterministic hash
- [ ] Track mesh vs billboard instance counts for separate draw calls
- [ ] Implement `VegetationSpawner.ts` class
- [ ] Add batch spawning for multiple tiles

---

## Phase 4: Rendering (Hybrid Billboard + 3D Mesh)

**Goal:** Instanced rendering supporting both billboard quads (far range) and 3D meshes (close range) with distance-based transitions.

### LOD Distance Strategy

| Distance Range | `hybrid` Mode | `mesh` Mode | `billboard` Mode |
|----------------|---------------|-------------|------------------|
| 0 ‚Äì billboardDist | 3D mesh LOD0 | 3D mesh LOD0 | Billboard |
| billboardDist ‚Äì maxDist | Billboard | ‚Äî (culled) | Billboard |
| > maxDist | Culled | Culled | Culled |

The `billboardDistance` per-plant defaults:
- Small plants (grass, flowers): 50m
- Medium plants (ferns, shrubs): 100m
- Large plants (trees, palms): 200m

### 4a: Billboard Rendering

#### `billboard.wgsl`

```wgsl
struct Uniforms {
  viewProjection: mat4x4f,
  cameraPosition: vec3f,
  time: f32,
}

struct WindParams {
  direction: vec2f,
  strength: f32,
  frequency: f32,
  gustStrength: f32,
  gustFrequency: f32,
  _pad: vec2f,
}

@group(0) @binding(0) var<uniform> uniforms: Uniforms;
@group(0) @binding(1) var<uniform> wind: WindParams;
@group(0) @binding(2) var<storage, read> instances: array<PlantInstance>;

// Atlas or billboard texture
@group(0) @binding(3) var plantTexture: texture_2d<f32>;
@group(0) @binding(4) var plantSampler: sampler;

struct VertexOutput {
  @builtin(position) position: vec4f,
  @location(0) uv: vec2f,
  @location(1) color: vec3f,
  @location(2) worldPos: vec3f,
}

fn applyWind(worldPos: vec3f, vertexHeight: f32) -> vec3f {
  let phase = dot(worldPos.xz, wind.direction) * 0.1 + uniforms.time * wind.frequency;
  let baseWind = sin(phase) * wind.strength;
  
  let gustUV = worldPos.xz * wind.gustFrequency + uniforms.time * 0.3;
  let gustNoise = fbm2D(gustUV, 2u) * 2.0 - 1.0;
  let localGust = gustNoise * wind.gustStrength;
  
  let displacement = (baseWind + localGust) * vertexHeight * vertexHeight;
  
  return worldPos + vec3f(wind.direction.x, 0.0, wind.direction.y) * displacement;
}

@vertex
fn vertexMain(input: VertexInput) -> VertexOutput {
  let instance = instances[input.instanceIndex];
  
  // Skip mesh-flagged instances (renderFlag > 0.5)
  if (instance.rotationAndType.z > 0.5) {
    // Degenerate triangle ‚Äî effectively culled
    var output: VertexOutput;
    output.position = vec4f(0.0, 0.0, 0.0, 0.0);
    return output;
  }
  
  // ... billboard quad generation, Y-axis aligned ...
  // ... wind displacement ...
  // ... texture atlas UV mapping ...
}

@fragment
fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
  let color = textureSample(plantTexture, plantSampler, input.uv);
  
  // Alpha cutout for vegetation edges
  if (color.a < 0.5) { discard; }
  
  // Distance fade
  let dist = distance(input.worldPos, uniforms.cameraPosition);
  let fade = 1.0 - smoothstep(150.0, 200.0, dist);
  
  return vec4f(color.rgb, color.a * fade);
}
```

#### `VegetationBillboardRenderer.ts`

```typescript
export class VegetationBillboardRenderer {
  constructor(ctx: GPUContext);
  initialize(depthFormat: GPUTextureFormat): void;
  
  render(
    passEncoder: GPURenderPassEncoder,
    viewProjection: mat4,
    cameraPosition: vec3,
    instanceBuffer: GPUBuffer,
    instanceCount: number,
    texture: UnifiedGPUTexture | null,  // Atlas or billboard texture
    wind: WindParams,
    time: number
  ): void;
  
  destroy(): void;
}
```

### 4b: 3D Mesh Rendering (Instanced)

#### Multi-Mesh Model Support

A single GLTF/GLB can contain multiple sub-meshes (trunk, branches, leaves). The renderer draws all sub-meshes per instance.

```typescript
interface VegetationMesh {
  id: string;
  name: string;
  subMeshes: VegetationSubMesh[];
  boundingBox: BoundingBox;
  castsShadow: boolean;
  receivesWind: boolean;
}

interface VegetationSubMesh {
  vertexBuffer: GPUBuffer;
  indexBuffer: GPUBuffer;
  indexCount: number;
  materialIndex: number;
  material: VegetationMaterial;
  windMultiplier: number;  // 0 = rigid (trunk), 1 = full wind (leaves)
}
```

#### Wind Per Sub-Mesh

| Sub-Mesh | Wind Multiplier | Behavior |
|----------|-----------------|----------|
| Trunk | 0.0 | Rigid, no movement |
| Branches | 0.3 | Slight sway |
| Leaves | 1.0 | Full flutter |
| Flowers | 0.8 | Strong sway |

#### `vegetation-mesh.wgsl`

```wgsl
struct MeshUniforms {
  viewProjection: mat4x4f,
  cameraPosition: vec3f,
  time: f32,
  windMultiplier: f32,  // Per-submesh
  _pad: vec3f,
}

@group(0) @binding(0) var<uniform> uniforms: MeshUniforms;
@group(0) @binding(1) var<uniform> wind: WindParams;
@group(0) @binding(2) var<storage, read> instances: array<PlantInstance>;

// Material textures
@group(1) @binding(0) var baseColorTexture: texture_2d<f32>;
@group(1) @binding(1) var normalTexture: texture_2d<f32>;
@group(1) @binding(2) var ormTexture: texture_2d<f32>;   // Occlusion-Roughness-Metallic
@group(1) @binding(3) var materialSampler: sampler;

@vertex
fn vertexMain(
  @builtin(instance_index) instanceIndex: u32,
  @location(0) position: vec3f,
  @location(1) normal: vec3f,
  @location(2) uv: vec2f,
) -> VertexOutput {
  let instance = instances[instanceIndex];
  
  // Skip billboard-flagged instances (renderFlag < 0.5)
  if (instance.rotationAndType.z < 0.5) {
    var output: VertexOutput;
    output.position = vec4f(0.0, 0.0, 0.0, 0.0);
    return output;
  }
  
  let worldPosBase = instance.positionAndScale.xyz;
  let scale = instance.positionAndScale.w;
  let rotation = instance.rotationAndType.x;
  
  // Apply rotation around Y axis
  let cosR = cos(rotation);
  let sinR = sin(rotation);
  let rotatedPos = vec3f(
    position.x * cosR - position.z * sinR,
    position.y,
    position.x * sinR + position.z * cosR
  );
  
  var worldPos = worldPosBase + rotatedPos * scale;
  
  // Apply wind (vertex height determines influence)
  let vertexHeight = saturate(position.y / meshHeight);
  worldPos = applyMeshWind(worldPos, vertexHeight, uniforms.windMultiplier);
  
  // ... project and output ...
}

@fragment
fn fragmentMain(input: VertexOutput) -> @location(0) vec4f {
  let baseColor = textureSample(baseColorTexture, materialSampler, input.uv);
  
  // Alpha cutout (for leaves, petals)
  if (baseColor.a < 0.5) { discard; }
  
  // PBR shading with normal + ORM maps
  // ... (reuse existing pbr.wgsl includes) ...
  
  return vec4f(finalColor, baseColor.a);
}
```

#### `VegetationMeshRenderer.ts`

```typescript
export class VegetationMeshRenderer {
  constructor(ctx: GPUContext);
  initialize(depthFormat: GPUTextureFormat): void;
  
  // Load a vegetation model from GLTF
  loadMesh(modelPath: string): Promise<VegetationMesh>;
  
  // Render all mesh instances
  render(
    passEncoder: GPURenderPassEncoder,
    viewProjection: mat4,
    cameraPosition: vec3,
    mesh: VegetationMesh,
    instanceBuffer: GPUBuffer,
    instanceCount: number,
    wind: WindParams,
    time: number
  ): void {
    // Set instance buffer once for the whole model
    // Draw each sub-mesh with the same instances
    for (const subMesh of mesh.subMeshes) {
      // Set per-submesh material/geometry
      pass.setBindGroup(1, subMesh.materialBindGroup);
      pass.setVertexBuffer(0, subMesh.vertexBuffer);
      pass.setIndexBuffer(subMesh.indexBuffer, 'uint32');
      
      // Wind multiplier in uniform
      this.updateWindMultiplier(subMesh.windMultiplier);
      
      pass.drawIndexed(subMesh.indexCount, instanceCount);
    }
  }
  
  destroy(): void;
}
```

### 4c: Orchestrating Renderer (`VegetationRenderer.ts`)

```typescript
/**
 * VegetationRenderer - Orchestrates billboard and mesh renderers.
 * Routes instances to the correct renderer based on renderFlag.
 */
export class VegetationRenderer {
  private billboardRenderer: VegetationBillboardRenderer;
  private meshRenderer: VegetationMeshRenderer;
  
  constructor(ctx: GPUContext);
  initialize(depthFormat: GPUTextureFormat): void;
  
  render(
    passEncoder: GPURenderPassEncoder,
    viewProjection: mat4,
    cameraPosition: vec3,
    tiles: Map<string, VegetationTileData>,
    wind: WindParams,
    time: number
  ): void {
    // For each tile's instance buffer:
    // 1. Draw billboard instances (renderFlag = 0) via billboardRenderer
    // 2. Draw mesh instances (renderFlag = 1) via meshRenderer
    // Both use the SAME instance buffer ‚Äî shaders skip non-matching instances
  }
  
  destroy(): void;
}
```

### Tasks
- [ ] Create `billboard.wgsl` vertex/fragment shader
- [ ] Implement Y-axis aligned billboarding
- [ ] Add wind displacement with base oscillation
- [ ] Add GPU-computed local gusts (FBM noise)
- [ ] Implement distance-based alpha fade
- [ ] Add alpha cutout for vegetation edges
- [ ] Create `VegetationBillboardRenderer.ts`
- [ ] Set up instanced billboard draw calls
- [ ] Create `vegetation-mesh.wgsl` vertex/fragment shader
- [ ] Implement per-instance Y-axis rotation
- [ ] Add per-submesh wind multiplier
- [ ] Reuse PBR shading from existing `pbr.wgsl`
- [ ] Create `VegetationMeshRenderer.ts`
- [ ] Implement GLTF loading for vegetation meshes
- [ ] Set up multi-submesh instanced draw calls
- [ ] Create `VegetationRenderer.ts` orchestrator
- [ ] Handle shared instance buffer routing (billboard vs mesh)

---

## Phase 5: LOD & Tile Caching

**Goal:** Manage vegetation instances per terrain tile with LOD-aware caching and hybrid mesh/billboard transitions.

### LOD Density Mapping

| Terrain LOD | Vegetation Density | Max Distance |
|-------------|-------------------|--------------|
| 0 (closest) | 100% | 0-50m |
| 1 | 60% | 50-100m |
| 2 | 30% | 100-200m |
| 3 | 10% | 200-400m |
| 4+ | 0% | >400m |

### `VegetationTileCache.ts`

```typescript
interface VegetationTileData {
  tileId: string;
  lodLevel: number;
  instanceBuffer: GPUBuffer;
  totalInstanceCount: number;
  meshInstanceCount: number;
  billboardInstanceCount: number;
  lastUsedFrame: number;
  bounds: BoundingBox;
}

export class VegetationTileCache {
  private tiles: Map<string, VegetationTileData> = new Map();
  private maxCacheSize: number = 100;
  private currentFrame: number = 0;
  
  // Called when terrain tile becomes visible
  onTileVisible(tileId: string, lodLevel: number, bounds: BoundingBox): void;
  
  // Called when terrain tile LOD changes
  onTileLODChange(tileId: string, oldLod: number, newLod: number): void;
  
  // Called when terrain tile becomes invisible
  onTileHidden(tileId: string): void;
  
  // Get tiles to render
  getVisibleTiles(): VegetationTileData[];
  
  // Evict old tiles (LRU)
  evictOldTiles(): void;
  
  // Connect to terrain CDLOD events
  connectToTerrain(terrainManager: TerrainManager): void;
}
```

### Integration with CDLOD

```typescript
// In CDLODRendererGPU.ts or TerrainQuadtree.ts
interface TileVisibilityCallback {
  onTileVisible(tileId: string, lodLevel: number, bounds: BoundingBox): void;
  onTileLODChange(tileId: string, oldLod: number, newLod: number): void;
  onTileHidden(tileId: string): void;
}

// Emit events during quadtree traversal
```

### Tasks
- [ ] Create `VegetationTileCache.ts` class
- [ ] Implement tile lifecycle management
- [ ] Add LRU eviction policy
- [ ] Define LOD-to-density mapping
- [ ] Track mesh vs billboard instance counts per tile
- [ ] Add tile visibility callbacks to CDLOD
- [ ] Connect vegetation cache to terrain tile events

---

## Phase 6: VegetationManager Integration

**Goal:** High-level orchestration connecting all vegetation components.

### `VegetationManager.ts`

```typescript
export class VegetationManager {
  private ctx: GPUContext;
  private plantRegistry: PlantRegistry;
  private biomeMaskGenerator: BiomeMaskGenerator;
  private spawner: VegetationSpawner;
  private renderer: VegetationRenderer;
  private tileCache: VegetationTileCache;
  
  private biomeMask: UnifiedGPUTexture | null = null;
  private config: VegetationConfig;
  private wind: WindParams;
  
  // Loaded vegetation meshes (from GLTF)
  private meshCache: Map<string, VegetationMesh> = new Map();
  
  constructor(ctx: GPUContext);
  
  initialize(): void;
  
  // Generate biome mask from terrain data
  generateBiomeMask(
    heightmap: UnifiedGPUTexture,
    flowMap: UnifiedGPUTexture | null,
    params?: Partial<BiomeParams>
  ): void;
  
  // Load a vegetation mesh from the asset library
  async loadVegetationMesh(modelRef: ModelReference): Promise<VegetationMesh>;
  
  // Connect to TerrainManager for tile events
  connectToTerrain(terrainManager: TerrainManager): void;
  
  // Called each frame
  update(cameraPosition: vec3, deltaTime: number): void;
  
  // Render vegetation (both billboards and meshes)
  render(
    passEncoder: GPURenderPassEncoder,
    viewProjection: mat4,
    cameraPosition: vec3
  ): void;
  
  // Configuration
  setConfig(config: Partial<VegetationConfig>): void;
  setWind(params: Partial<WindParams>): void;
  
  // Debug
  getBiomeMask(): UnifiedGPUTexture | null;
  getStats(): { tileCount: number; totalInstances: number; meshInstances: number; billboardInstances: number };
  
  destroy(): void;
}
```

### Integration with Render Pipeline

```typescript
// In GPUForwardPipeline.ts
renderVegetation(
  passEncoder: GPURenderPassEncoder,
  context: RenderContext
): void {
  if (!this.vegetationManager?.isEnabled()) return;
  
  this.vegetationManager.render(
    passEncoder,
    context.viewProjectionMatrix,
    context.cameraPosition
  );
}
```

### Tasks
- [ ] Create `VegetationManager.ts` class
- [ ] Implement initialization and lifecycle
- [ ] Add biome mask generation trigger
- [ ] Add vegetation mesh loading and caching
- [ ] Connect to TerrainManager
- [ ] Implement per-frame update
- [ ] Add render method (routes to billboard + mesh renderers)
- [ ] Expose configuration setters
- [ ] Add to GPUForwardPipeline

---

## Phase 7: UI & Polish

**Goal:** Add user controls and optimize performance.

### Vegetation Editor Updates

The existing `VegetationContent.tsx` needs updates for model support:

```tsx
function PlantItem({ plant, onUpdate, onDelete, onSelectAtlas, onSelectModel }: PlantItemProps) {
  return (
    <div class={styles.plantItem}>
      {/* Header */}
      <div class={styles.plantHeader}>
        <span>{plant.name}</span>
        <div class={styles.plantActions}>
          <button onClick={onSelectModel} title="Select 3D model">üå≥</button>
          <button onClick={onSelectAtlas} title="Select texture atlas">üñºÔ∏è</button>
          <button onClick={onDelete} title="Delete">üóëÔ∏è</button>
        </div>
      </div>
      
      {expanded && (
        <div class={styles.plantProperties}>
          {/* Render Mode Selector */}
          <div class={styles.propertyRow}>
            <label>Render Mode</label>
            <select 
              value={plant.renderMode}
              onChange={(e) => onUpdate({ renderMode: e.target.value })}
            >
              <option value="billboard">Billboard Only</option>
              <option value="mesh">3D Mesh Only</option>
              <option value="hybrid">Hybrid (3D + Billboard)</option>
            </select>
          </div>
          
          {/* Model info (when model assigned) */}
          {plant.modelRef && (
            <div class={styles.modelInfo}>
              <span>Model: {plant.modelRef.assetName}</span>
              {plant.modelRef.billboardTexturePath && (
                <span class={styles.hasBillboard}>‚úì Has billboard</span>
              )}
            </div>
          )}
          
          {/* Billboard Distance (hybrid mode only) */}
          {plant.renderMode === 'hybrid' && (
            <div class={styles.propertyRow}>
              <label>Billboard Distance (m)</label>
              <input 
                type="range" min="20" max="400" step="10"
                value={plant.billboardDistance}
                onInput={(e) => onUpdate({ billboardDistance: parseFloat(e.target.value) })}
              />
              <span>{plant.billboardDistance}m</span>
            </div>
          )}
          
          {/* ... existing properties (spawn probability, size, clustering, etc.) ... */}
        </div>
      )}
    </div>
  );
}
```

### Model Picker Integration

The existing `AssetPickerModal` already supports filtering by type/subtype. For model picking:

```tsx
// Open model picker with vegetation model filter
<AssetPickerModal
  isOpen={isModelPickerOpen}
  onClose={() => setModelPickerOpen(false)}
  onSelect={handleModelSelected}
  title="Select Vegetation Model"
  filterType="model"
  filterCategory="vegetation"  // Uses path-based detection
/>
```

The `handleModelSelected` callback:
```typescript
const handleModelSelected = useCallback(async (asset: Asset) => {
  if (!selectedPlantId) return;
  
  // Find standard GLTF file
  const gltfFile = asset.files.find(f => 
    f.path.includes('nonUE') && (f.format === 'gltf' || f.format === 'glb')
  );
  
  // Find billboard textures
  const billboardBO = asset.files.find(f => 
    f.path.toLowerCase().includes('billboard') && f.path.includes('B-O')
  );
  const billboardNT = asset.files.find(f => 
    f.path.toLowerCase().includes('billboard') && f.path.includes('N-T')
  );
  
  if (!gltfFile) {
    console.error('No standard GLTF found for asset:', asset.name);
    return;
  }
  
  const modelRef: ModelReference = {
    assetId: asset.id,
    assetName: asset.name,
    modelPath: gltfFile.path,
    billboardTexturePath: billboardBO?.path ?? null,
    billboardNormalPath: billboardNT?.path ?? null,
    variantCount: 1,
  };
  
  registry.setPlantModel(selectedBiome, selectedPlantId, modelRef);
  
  // Auto-set to hybrid mode if both model and billboard texture available
  if (billboardBO) {
    registry.updatePlant(selectedBiome, selectedPlantId, { renderMode: 'hybrid' });
  } else {
    registry.updatePlant(selectedBiome, selectedPlantId, { renderMode: 'mesh' });
  }
}, [registry, selectedBiome, selectedPlantId]);
```

### Performance Optimizations

1. **Frustum culling** ‚Äî Skip tiles outside view frustum
2. **GPU buffer pooling** ‚Äî Reuse instance buffers
3. **Async spawning** ‚Äî Don't block main thread
4. **Distance sorting** ‚Äî Render front-to-back for early Z rejection
5. **Instance count limits** ‚Äî Cap per-tile instances
6. **GPU indirect draw** ‚Äî Use indirect draw calls to avoid CPU readback of instance counts

### Tasks
- [ ] Update VegetationContent.tsx with model picker button (üå≥ icon)
- [ ] Add render mode selector (billboard/mesh/hybrid dropdown)
- [ ] Add billboardDistance slider for hybrid mode
- [ ] Show model info when model assigned
- [ ] Add handleModelSelected callback (auto-detect GLTF + billboard textures)
- [ ] Add setPlantModel() method to PlantRegistry
- [ ] Implement frustum culling
- [ ] Add GPU buffer pooling
- [ ] Performance profiling and optimization

---

## Summary

### File Structure (Final)

```
src/core/vegetation/
‚îú‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ types.ts
‚îú‚îÄ‚îÄ VegetationManager.ts
‚îú‚îÄ‚îÄ BiomeMaskGenerator.ts
‚îú‚îÄ‚îÄ VegetationSpawner.ts
‚îú‚îÄ‚îÄ VegetationRenderer.ts
‚îú‚îÄ‚îÄ VegetationBillboardRenderer.ts
‚îú‚îÄ‚îÄ VegetationMeshRenderer.ts
‚îú‚îÄ‚îÄ VegetationTileCache.ts
‚îú‚îÄ‚îÄ PlantRegistry.ts
‚îî‚îÄ‚îÄ AtlasRegionDetector.ts

src/core/gpu/shaders/vegetation/
‚îú‚îÄ‚îÄ biome-mask.wgsl
‚îú‚îÄ‚îÄ spawn.wgsl
‚îú‚îÄ‚îÄ billboard.wgsl
‚îî‚îÄ‚îÄ vegetation-mesh.wgsl
```

### Data Flow

```
[Heightmap] + [Flow Map] ‚Üí [BiomeMaskGenerator] ‚Üí [Biome Mask]
                                                        ‚Üì
[Camera Position] + [Tile Bounds] ‚Üí [VegetationSpawner] ‚Üí [Instance Buffers]
                                                                ‚Üì
                                    [VegetationRenderer] ‚Üí Split by renderFlag
                                         ‚Üì                        ‚Üì
                           [MeshRenderer]              [BillboardRenderer]
                           (close range 3D)            (far range quads)
```

### Progress Tracking

#### Phase 0: Water Flow Map [Complete]
- [x] flowAccumulation atomic buffer in hydraulic-erosion.wgsl
- [x] Track droplet visits with atomicAdd
- [x] finalizeFlowMap entry point
- [x] ErosionSimulator flow buffer + texture + pipeline
- [x] Clear flow buffer at erosion start
- [x] getFlowMap() accessor on ErosionSimulator
- [x] TerrainManager exposes flow map

#### Phase 1: Biome Mask [Complete]
- [x] biome-mask.wgsl compute shader
- [x] BiomeMaskGenerator.ts (full pipeline)
- [x] BiomeParams interface (expanded to 13 fields)
- [x] Sample heightmap, slope, flow
- [x] Output RGBA biome probabilities
- [x] Integrate with TerrainManager
- [x] BiomeMask dockable editor UI

#### Phase 2: Plant Foundation [Complete]
- [x] types.ts (PlantType, AtlasRegion, BiomePlantConfig, VegetationConfig, WindParams)
- [x] PlantRegistry.ts (dynamic registry with events, CRUD, serialization)
- [x] Default grassland + forest plant presets
- [x] Atlas region injection (setPlantAtlas)
- [x] AtlasRegionDetector.ts (connected component analysis)
- [x] VegetationContent.tsx (UI panel with biome tabs)
- [x] AssetPickerModal (reusable asset selection modal)
- [x] VegetationPanelBridge (DockableWindow integration)
- [x] PlantRegistry integrated into TerrainManager
- [x] Add ModelReference type + renderMode + billboardDistance to PlantType
- [x] Add model picker UI and setPlantModel() to PlantRegistry
- [x] Add render mode selector to vegetation editor

#### Phase 3: Spawning [Complete]
- [x] spawn.wgsl compute shader
- [x] Grid-based spawning with jitter
- [x] Biome mask sampling
- [x] Terrain height positioning
- [x] Distance-based density falloff
- [x] Per-instance render flag (billboard vs mesh)
- [x] Variant index selection
- [x] VegetationSpawner.ts (with buffer pooling, counter readback)
- [x] Batch spawning (spawnTile for multiple plant types)

#### Phase 4: Rendering (Hybrid) [Complete]
- [x] billboard.wgsl (billboard vertex/fragment)
- [x] VegetationBillboardRenderer.ts
- [x] Y-axis billboarding + wind + alpha cutout
- [x] vegetation-mesh.wgsl (instanced mesh vertex/fragment)
- [x] VegetationMeshRenderer.ts
- [x] GLTF mesh loading for vegetation (implemented in VegetationManager)
- [x] Multi-submesh instanced draw + per-submesh wind
- [x] VegetationRenderer.ts (orchestrator)

#### Phase 5: LOD & Caching [Complete]
- [x] VegetationTileCache.ts
- [x] Tile lifecycle management (onTileVisible, onTileHidden, onTileLODChange)
- [x] LRU eviction (evictOldTiles with frame-based aging)
- [x] LOD density mapping (DEFAULT_LOD_DENSITIES, getLODDensity)
- [x] Buffer pool for instance buffer reuse
- [x] Mesh/billboard count tracking per tile
- [x] CDLOD tile event integration (implemented in VegetationManager)

#### Phase 6: Integration [Complete]
- [x] VegetationManager.ts (full orchestrator)
- [x] GLTF mesh loading + caching (GLBLoader ‚Üí VegetationMesh conversion)
- [x] Billboard texture loading + caching
- [x] Connect to TerrainManager (connectToTerrain, updateTerrainData)
- [x] CDLOD tile event hooks (onTerrainTileVisible/Hidden/LODChange)
- [x] Per-frame update with spawning throttle (max 4 tiles/frame)
- [x] Render method routing to VegetationRenderer
- [x] Configuration + statistics API
- [x] **TerrainManager integration**: VegetationManager instantiated in initialize(), connected after generate(), render() called after terrain render in same pass
- [x] **OpaquePass flow**: OpaquePass ‚Üí terrainManager.render() ‚Üí vegetation.render() (automatic, no OpaquePass changes needed)
- [x] Accessors: getVegetationManager(), hasVegetationManager()
- [x] Cleanup in destroy()

#### Phase 7: UI & Polish [Complete]
- [x] VegetationContent.tsx updated with model picker + render mode (done in Phase 2)
- [x] Wind controls in UI (connected to PlantRegistry wind params)
- [x] Frustum culling (AABB vs 6 frustum planes extracted from VP matrix)
- [x] Front-to-back distance sorting for early-Z rejection
- [x] GPU buffer pooling (VegetationSpawner + VegetationTileCache)
- [x] Async spawn throttle (max 4 tiles/frame)
- [x] Instance count caps (65K per tile)
- [ ] GPU indirect draw (deferred ‚Äî eliminates counter readback stall)
- [ ] WebGPU timestamp profiling queries

---

## Current Asset Inventory

### Vegetation 3D Models (with Billboard Textures)

All Quixel/Megascans models include both 3D GLTF and pre-rendered billboard textures ‚Äî ideal for `hybrid` rendering mode.

| Asset | Path | 3D GLTF | Billboard B-O | Billboard N-T | Recommended Mode |
|-------|------|---------|---------------|---------------|------------------|
| **Alexandra Palm** | `vegetation/alexandra_palm_ukgkcilia_ue_high/` | ‚úÖ `standard/ukgkcilia_tier_1_nonUE.gltf` | ‚úÖ | ‚úÖ | hybrid (200m) |
| **Beech Fern** | `vegetation/beech_fern_vmkpdbeia_ue_high/` | ‚úÖ `standard/vmkpdbeia_tier_1_nonUE.gltf` | ‚úÖ | ‚úÖ | hybrid (100m) |
| **Bigleaf Hydrangea** | `vegetation/bigleaf_hydrangea_vgztealha_ue_high/` | ‚úÖ `standard/vgztealha_tier_1_nonUE.gltf` | ‚úÖ | ‚úÖ | hybrid (100m) |
| **Dead Shrubs** | `vegetation/dead_shrubs_vdknafgha_ue_high/` | ‚úÖ `standard/vdknafgha_tier_1_nonUE.gltf` | ‚úÖ | ‚úÖ | hybrid (80m) |
| **Field Poppy** | `vegetation/field_poppy_vmcobd0ja_ue_high/` | ‚úÖ `standard/vmcobd0ja_tier_1_nonUE.gltf` | ‚úÖ | ‚úÖ | hybrid (50m) |
| **Lady Fern** | `vegetation/lady_fern_wdvlditia_ue_high/` | ‚úÖ `standard/wdvlditia_tier_1_nonUE.gltf` | ‚úÖ | ‚úÖ | hybrid (100m) |
| **Ribbon Grass** | `vegetation/ribbon_grass_tbdpec3r_ue_high/` | ‚úÖ `standard/tbdpec3r_tier_1_nonUE.gltf` | ‚úÖ | ‚úÖ | hybrid (50m) |
| **Wheat Grass** | `vegetation/wheat_grass_tdcrdbur_ue_high/` | ‚úÖ `standard/tdcrdbur_tier_1_nonUE.gltf` | ‚úÖ | ‚úÖ | hybrid (50m) |
| **Wild Grass** | `vegetation/wild_grass_vczndjqja_ue_high/` | ‚úÖ `standard/vczndjqja_tier_1_nonUE.gltf` | ‚úÖ | ‚úÖ | hybrid (50m) |
| **Billboard Tree Pack** | `vegetation/billboard_tree_pack_gltf/` | ‚úÖ `scene.gltf` (billboards as meshes) | ‚ùå | ‚ùå | billboard |

### Texture Atlases

| Asset | Path | Type | Ready to Use |
|-------|------|------|--------------|
| **Bracken Fern** | `textures/atlas/vegetation/bracken_fern_okdr22_4k/` | Atlas (needs RGBA combine) | ‚ö†Ô∏è Needs preprocessing |
| **Clover Patches** | `textures/vegetation/clover_patches_on_grass_sgmkajak_4k/` | Ground vegetation material | ‚úÖ |
| **Nordic Forest Ground** | `textures/vegetation/nordic_forest_ground_root_moss_coarse_xiekec0_4k/` | Ground vegetation material | ‚úÖ |

### Quixel Vegetation Texture Naming Convention

Each Quixel model includes these texture maps in its `Textures/` folder:
- `T_{id}_4K_B.png` ‚Äî BaseColor only
- `T_{id}_4K_B-O.png` ‚Äî BaseColor + Opacity combined
- `T_{id}_4K_N.png` ‚Äî Normal map
- `T_{id}_4K_ORT.png` ‚Äî Occlusion + Roughness + Translucency
- `T_{id}_4K_Billboard_B-O.png` ‚Äî Billboard BaseColor + Opacity
- `T_{id}_4K_Billboard_N-T.png` ‚Äî Billboard Normal + Translucency

For 3D mesh rendering, use `B-O.png` (with alpha cutout) + `N.png` + `ORT.png`.
For billboard rendering, use `Billboard_B-O.png` (with alpha cutout).

---

## Asset Library Integration

The **Asset Library Server** (`server/`) provides a centralized system for indexing, previewing, and serving vegetation assets. This enables the vegetation system to discover available plant models and textures at runtime.

### Architecture

```
server/
‚îú‚îÄ‚îÄ index.ts                    # Express server with REST API
‚îú‚îÄ‚îÄ db/
‚îÇ   ‚îî‚îÄ‚îÄ database.ts             # SQLite database (assets, files, metadata)
‚îî‚îÄ‚îÄ services/
    ‚îú‚îÄ‚îÄ AssetIndexer.ts         # Scans public/ for assets
    ‚îú‚îÄ‚îÄ FileWatcher.ts          # Live reload on asset changes
    ‚îî‚îÄ‚îÄ PreviewGenerator.ts     # Thumbnail generation
```

### Asset Discovery Flow

```
[Asset Library Server]
        ‚Üì
1. Scans public/models/terrain/vegetation/
2. Parses GLTF, manifest.json, texture packs
3. Indexes to SQLite (asset_files table)
        ‚Üì
[VegetationManager]
        ‚Üì
4. Queries /api/assets?type=vegetation or /api/assets?type=model&category=vegetation
5. Receives asset metadata + file paths
6. Loads models/textures on demand
```

### API Endpoints for Vegetation

| Endpoint | Method | Description |
|----------|--------|-------------|
| `/api/assets?type=model&category=vegetation` | GET | 3D vegetation models |
| `/api/assets?type=texture&subtype=atlas` | GET | Texture atlases |
| `/api/assets/:id` | GET | Full asset details with files |
| `/api/previews/:id.webp` | GET | Thumbnail preview |

### Integration Tasks
- [ ] Ensure AssetIndexer detects vegetation assets by folder path (`/vegetation/`)
- [ ] Add VegetationAssetLoader class that queries asset library
- [ ] Cache loaded vegetation meshes and textures
- [ ] Add hot-reload support for vegetation asset changes

---

## Test Plan

This section documents manual testing steps for verifying the vegetation system end-to-end. Follow these steps in order after starting the app.

### Prerequisites
- Run `npm run dev` to start the development server
- Run the asset server (`npm run server` or equivalent) so the Asset Library is available
- Open the Scene Builder in browser

---

### Test 1: Terrain Generation (Baseline)

**Action:** Generate a terrain if one doesn't already exist.
1. Open the **Terrain Panel** (left sidebar)
2. Click **Generate** with default settings (or any settings that produce visible hills)
3. Wait for generation to complete

**Expected:** A terrain mesh renders in the viewport with hills, valleys, and proper lighting. Console should show `[TerrainManager] CPU heightfield ready` and `[VegetationManager] Initialized` and `[VegetationManager] Connected to terrain`.

**Status:** Pass

---

### Test 2: Biome Mask Generation

**Action:** Generate a biome mask from the terrain.
1. In the **Terrain Panel**, find the button to open the **Biome Mask Editor** (should be a dockable window button)
2. Click it ‚Äî a dockable window should appear with a preview and parameter sliders
3. Click **Generate** or adjust sliders ‚Äî the biome mask preview should update

**Expected:** A colored texture preview appears showing:
- **Red/yellow** areas = grassland (moderate height, low slope)
- **Green** areas = rock/cliff (steep slopes)
- **Blue/cyan** areas = forest (near water flow)
- **Black** areas = no vegetation (extreme terrain)

Adjusting sliders like `grassSlopeMax` or `rockSlopeMin` should live-update the preview.

**Status:** ‚òê Pass / ‚òê Fail / ‚òê N/A

---

### Test 3: Vegetation Editor ‚Äî View Default Plants

**Action:** Open the vegetation editor.
1. In the **Terrain Panel**, find the button to open the **Vegetation Editor** (dockable window)
2. The editor should show **3 biome tabs**: Grassland (5), Rock/Cliff (0), Forest Edge (2)
3. Click the **Grassland** tab

**Expected:** 5 default plant types listed: Tall Grass, Short Grass Clump, Yellow Wildflower, Purple Wildflower, Small Shrub. Each shows a colored swatch, expand arrow, and action buttons (üå≥ model, üñºÔ∏è texture, üóëÔ∏è delete).

**Status:** ‚òê Pass / ‚òê Fail / ‚òê N/A

---

### Test 4: Plant Editor ‚Äî Expand and Edit Properties

**Action:** Expand a plant type to see its properties.
1. Click on **"Tall Grass"** to expand it
2. Verify the following controls are visible:
   - Name text field
   - **Render Mode** dropdown (Billboard Only / 3D Mesh Only / Hybrid)
   - Spawn Probability slider
   - Biome Threshold slider
   - Size Range inputs (Min W, Min H, Max W, Max H)
   - Clustering slider
   - Min Spacing input
   - Max Distance input
   - LOD Bias slider
   - Fallback Color picker

**Expected:** All controls render correctly. Default render mode should be "Billboard Only". No model or atlas info shown (none assigned yet).

**Status:** ‚òê Pass / ‚òê Fail / ‚òê N/A

---

### Test 5: Assign a 3D Model to a Plant

**Action:** Use the model picker to assign a vegetation GLTF.
1. Expand **"Tall Grass"** in the vegetation editor
2. Click the **üå≥ model button** in the header
3. A **"Select Vegetation Model"** modal should appear
4. Browse the model library ‚Äî you should see vegetation models (Ribbon Grass, Wild Grass, etc.)
5. Select **"Ribbon Grass"** (or any vegetation model) and click **Select**

**Expected:**
- Console logs: `[VegetationContent] Assigned model "Ribbon Grass" to plant (with billboard texture)`
- The plant item now shows **"Model: Ribbon Grass"** with a **‚úì Billboard** indicator
- Render mode auto-switches to **"Hybrid (3D + Billboard)"**
- A **Billboard Distance** slider appears (default ~100m)

**Status:** ‚òê Pass / ‚òê Fail / ‚òê N/A

---

### Test 6: Change Render Mode

**Action:** Switch render modes and observe the UI.
1. With the model assigned, change the **Render Mode** dropdown to each option:
   - **Billboard Only** ‚Äî Billboard Distance slider should disappear
   - **3D Mesh Only** ‚Äî Billboard Distance slider should disappear
   - **Hybrid** ‚Äî Billboard Distance slider should appear

**Expected:** UI updates correctly for each mode. No errors in console.

**Status:** ‚òê Pass / ‚òê Fail / ‚òê N/A

---

### Test 7: Assign a Texture Atlas

**Action:** Assign an atlas texture to a billboard-only plant.
1. Click **"Short Grass Clump"** to expand it
2. Click the **üñºÔ∏è texture button** in the header
3. A **"Select Texture Atlas"** modal should appear (filtered to texture atlases)
4. If atlases are available, select one and click **Select**

**Expected:**
- Console logs about atlas region detection
- Atlas info appears: "Atlas: [name] (N regions)"
- The plant remains in billboard mode

**Status:** ‚òê Pass / ‚òê Fail / ‚òê N/A (if no atlases indexed)

---

### Test 8: Vegetation Rendering (Visual ‚Äî Billboards)

> **Note:** This test verifies the render pipeline is connected. Currently the vegetation system spawns vegetation globally (not per-CDLOD-tile). You need a biome mask generated first.

**Action:** Check for vegetation rendering after terrain generation.
1. Ensure terrain is generated (Test 1)
2. Ensure biome mask is generated (Test 2)
3. Check browser console for: `[VegetationManager] Connected to terrain (size=..., heightScale=..., biomeMask=yes)`
4. Look at the viewport

**Expected (current state):** Vegetation may NOT render visually yet because:
- The `VegetationManager.update()` is not yet called from the animation loop (tile spawning requires `update()` to be called each frame)
- No tiles have been registered via `onTerrainTileVisible()` since the CDLOD traversal doesn't emit tile events yet

**What you SHOULD see in console:**
- `[VegetationManager] Initialized`
- `[VegetationManager] Connected to terrain`
- No WebGPU errors or shader compilation failures

**What you will NOT see yet:**
- Actual vegetation instances on the terrain (requires animation loop integration and tile event wiring)

**Status:** ‚òê Console OK / ‚òê Errors / ‚òê Visual vegetation renders

---

### Test 9: Global Settings

**Action:** Test the global vegetation settings.
1. In the Vegetation Editor, expand **"GLOBAL SETTINGS"**
2. Toggle **"Enable Vegetation"** checkbox
3. Adjust **"Global Density"** slider
4. Toggle **"Enable Wind"** checkbox
5. Adjust wind strength and frequency sliders

**Expected:** Controls save to PlantRegistry. No errors. Wind sliders only show when wind is enabled.

**Status:** ‚òê Pass / ‚òê Fail / ‚òê N/A

---

### Test 10: Add / Delete Plant Types

**Action:** Test CRUD operations.
1. Click **"+ Add Plant Type"** at the bottom
2. A new plant appears with a generated name
3. Expand it and edit properties
4. Click the **üóëÔ∏è delete button** on the new plant
5. Confirm deletion

**Expected:** Plant is added to the list. After deletion, it disappears. Biome tab count updates accordingly.

**Status:** ‚òê Pass / ‚òê Fail / ‚òê N/A

---

### Known Limitations (Current State)

These are expected gaps that need further work:

| Issue | Reason | Fix Needed |
|-------|--------|------------|
| No visible vegetation on terrain | `VegetationManager.update()` not called from animation loop | Wire `update()` into Viewport's render loop |
| No tile events from CDLOD | Quadtree traversal doesn't emit visibility events | Add callbacks in `TerrainQuadtree.select()` |
| Vegetation doesn't respond to biome mask changes | `updateTerrainData()` not called after biome regeneration | Wire BiomeMaskPanelBridge to call `vegetationManager.updateTerrainData(null, newBiomeMask)` |
| Console `mapAsync` timeout | Counter readback stalls if GPU is busy | Move to GPU indirect draw (deferred) |

---

## Future Enhancements

1. **Additional Biomes** ‚Äî Snow, desert, wetland
2. **Procedural Variation** ‚Äî Runtime plant color/shape variation
3. **Shadow Casting** ‚Äî Simple billboard shadows + mesh shadows via shadow map
4. **Cross-fading LOD** ‚Äî Smooth alpha transitions between 3D and billboard
5. **Seasonal Variation** ‚Äî Color shifts based on time/weather
6. **Interactive Vegetation** ‚Äî Player collision response
7. **Automatic Impostor Generation** ‚Äî Render 3D mesh from multiple angles to auto-generate billboard atlas
8. **GPU Indirect Draw** ‚Äî Use indirect draw calls to avoid CPU readback of instance counts
9. **Translucency/SSS** ‚Äî Subsurface scattering for leaves (Quixel ORT maps include translucency)
10. **KTX2/BC7 Compression** ‚Äî GPU-compressed textures for production

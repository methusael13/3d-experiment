# Lighting System Migration Plan: Lights as Scene Objects

## Overview

Migrate lights from a separate `LightingManager` to proper `SceneObject` instances managed by `Scene`, enabling unified serialization, selection, and scene graph integration.

---

## Architecture Flow Diagrams

### Current System (Before Migration)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              UI LAYER (Preact)                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                       â”‚
â”‚  â”‚   LightingTab.tsx    â”‚  â† User adjusts azimuth, elevation, ambient, etc.    â”‚
â”‚  â”‚   (Environment Panel)â”‚                                                       â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                       â”‚
â”‚             â”‚ onChange()                                                        â”‚
â”‚             â–¼                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                   â”‚
â”‚  â”‚ EnvironmentPanelBridge   â”‚  â† Converts UI state to light params             â”‚
â”‚  â”‚ context.onLightingChangedâ”‚                                                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                   â”‚
â”‚             â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              DEMO LAYER                                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚  â”‚   LightingManager    â”‚â—„â”€â”€â”€â”€â”€â”‚   DirectionalLight   â”‚  (SceneObject but      â”‚
â”‚  â”‚  (separate manager)  â”‚      â”‚   PointLight         â”‚   NOT in Scene!)       â”‚
â”‚  â”‚                      â”‚      â”‚   HDRLight           â”‚                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                        â”‚
â”‚             â”‚ getLightParams()                                                  â”‚
â”‚             â–¼                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                                       â”‚
â”‚  â”‚      Viewport        â”‚                                                       â”‚
â”‚  â”‚  setLightParams()    â”‚  â† Stores params, passes to pipeline                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                                       â”‚
â”‚             â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              CORE LAYER (GPU Pipeline)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                     â”‚
â”‚  â”‚       GPUForwardPipeline.render()      â”‚                                     â”‚
â”‚  â”‚  options.lightDirection                â”‚  â† Light params passed as options  â”‚
â”‚  â”‚  options.sunIntensity                  â”‚                                     â”‚
â”‚  â”‚  options.ambientIntensity              â”‚                                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                     â”‚
â”‚             â”‚                                                                   â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚
â”‚     â–¼               â–¼                â–¼                 â–¼                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚  Sky   â”‚   â”‚  Shadow   â”‚   â”‚  DynamicSky  â”‚  â”‚ SceneEnviron-  â”‚            â”‚
â”‚  â”‚Rendererâ”‚   â”‚ Renderer  â”‚   â”‚     IBL      â”‚  â”‚     ment       â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚       â”‚             â”‚                â”‚                  â”‚                      â”‚
â”‚       â”‚             â”‚                â”‚ IBL Textures     â”‚ Bind Group 3         â”‚
â”‚       â”‚             â”‚ Shadow Map     â–¼                  â”‚                      â”‚
â”‚       â”‚             â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚                      â”‚
â”‚       â”‚             â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚ Shared  â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚       â”‚                        â”‚ Uniformsâ”‚                                     â”‚
â”‚       â”‚                        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜                                     â”‚
â”‚       â”‚                             â”‚                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                             â”‚
        â–¼                             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              GPU SHADERS (WGSL)                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚    sky.wgsl      â”‚  â”‚    pbr.wgsl      â”‚  â”‚  terrain/cdlod   â”‚              â”‚
â”‚  â”‚  - sunDirection  â”‚  â”‚  - lightDir      â”‚  â”‚   .wgsl          â”‚              â”‚
â”‚  â”‚  - sunIntensity  â”‚  â”‚  - ambient       â”‚  â”‚  - lightDir      â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  - IBL sampling  â”‚  â”‚  - shadows       â”‚              â”‚
â”‚                        â”‚  - shadows       â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                     â”‚
â”‚                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Problems with Current Architecture:**
- Light objects extend SceneObject but are NOT stored in Scene
- Separate data flow for lights vs. other scene objects
- LightingManager creates coupling between demo layer and core
- Light params passed as render options, not queried from scene
- Cannot select/serialize lights with other scene objects

---

### New System (After Migration)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              UI LAYER (Preact)                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚  â”‚   Objects Panel      â”‚        â”‚    Object Panel      â”‚                      â”‚
â”‚  â”‚  â”œâ”€ â˜€ï¸ Sun           â”‚â—„â”€â”€â”€â”€â”€â”€â–ºâ”‚  (LightProperties    â”‚                      â”‚
â”‚  â”‚  â”œâ”€ ğŸ’¡ Point Light   â”‚ select â”‚   Section shown      â”‚                      â”‚
â”‚  â”‚  â”œâ”€ ğŸ”¦ Spot Light    â”‚        â”‚   when light         â”‚                      â”‚
â”‚  â”‚  â””â”€ ğŸ  Models...     â”‚        â”‚   selected)          â”‚                      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚             â”‚                               â”‚                                   â”‚
â”‚             â”‚ scene.select(lightId)         â”‚ light.intensity = v              â”‚
â”‚             â”‚                               â”‚ light.color = [r,g,b]            â”‚
â”‚             â”‚                               â”‚ dirLight.azimuth = deg           â”‚
â”‚             â–¼                               â–¼                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚                    ObjectPanelBridge                             â”‚          â”‚
â”‚  â”‚                    (detects light selection)                     â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                     â”‚ direct property mutation                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              CORE LAYER (Scene)                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚                           Scene                                   â”‚          â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚          â”‚
â”‚  â”‚  â”‚ objects: Map<string, SceneObject>                           â”‚ â”‚          â”‚
â”‚  â”‚  â”‚   â”œâ”€ Cubes, Planes, Models...                              â”‚ â”‚          â”‚
â”‚  â”‚  â”‚   â””â”€ â˜€ï¸ğŸ’¡ğŸ”¦ Lights (now included!)                          â”‚ â”‚          â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚          â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚          â”‚
â”‚  â”‚  â”‚ lights: Map<string, Light>  (efficient query index)         â”‚ â”‚          â”‚
â”‚  â”‚  â”‚   â”œâ”€ DirectionalLight (sun)                                 â”‚ â”‚          â”‚
â”‚  â”‚  â”‚   â”œâ”€ PointLight[]                                           â”‚ â”‚          â”‚
â”‚  â”‚  â”‚   â”œâ”€ SpotLight[]                                            â”‚ â”‚          â”‚
â”‚  â”‚  â”‚   â””â”€ AreaLight[]                                            â”‚ â”‚          â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚          â”‚
â”‚  â”‚                                                                   â”‚          â”‚
â”‚  â”‚  Query Methods:                                                   â”‚          â”‚
â”‚  â”‚    scene.getDirectionalLight()                                   â”‚          â”‚
â”‚  â”‚    scene.getPointLights()                                        â”‚          â”‚
â”‚  â”‚    scene.getSpotLights()                                         â”‚          â”‚
â”‚  â”‚    scene.getShadowCastingLights()                                â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                                     â”‚                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              GPU PIPELINE                                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                     â”‚
â”‚  â”‚       GPUForwardPipeline.render()      â”‚                                     â”‚
â”‚  â”‚                                        â”‚                                     â”‚
â”‚  â”‚  // Query lights directly from scene   â”‚                                     â”‚
â”‚  â”‚  const dirLight = scene.getDirectionalLight();                              â”‚
â”‚  â”‚  const pointLights = scene.getPointLights();                                â”‚
â”‚  â”‚  const spotLights = scene.getSpotLights();                                  â”‚
â”‚  â”‚                                        â”‚                                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                     â”‚
â”‚             â”‚                                                                   â”‚
â”‚             â–¼                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                     â”‚
â”‚  â”‚       LightBufferManager               â”‚  â† NEW: Manages GPU light buffers  â”‚
â”‚  â”‚                                        â”‚                                     â”‚
â”‚  â”‚  update(scene) {                       â”‚                                     â”‚
â”‚  â”‚    // Pack lights into GPU buffers     â”‚                                     â”‚
â”‚  â”‚    writeDirectionalLights(...)         â”‚                                     â”‚
â”‚  â”‚    writePointLights(...)               â”‚                                     â”‚
â”‚  â”‚    writeSpotLights(...)                â”‚                                     â”‚
â”‚  â”‚  }                                     â”‚                                     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                     â”‚
â”‚             â”‚                                                                   â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚
â”‚     â–¼               â–¼                â–¼                 â–¼                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚  Sky   â”‚   â”‚  Shadow   â”‚   â”‚  DynamicSky  â”‚  â”‚ SceneEnviron-  â”‚            â”‚
â”‚  â”‚Rendererâ”‚   â”‚ Renderer  â”‚   â”‚     IBL      â”‚  â”‚     ment       â”‚            â”‚
â”‚  â”‚        â”‚   â”‚           â”‚   â”‚              â”‚  â”‚                â”‚            â”‚
â”‚  â”‚ Uses   â”‚   â”‚ Per-light â”‚   â”‚ Updates from â”‚  â”‚ Bind Group 3:  â”‚            â”‚
â”‚  â”‚dirLightâ”‚   â”‚ shadow    â”‚   â”‚ dirLight     â”‚  â”‚ - Shadow maps  â”‚            â”‚
â”‚  â”‚params  â”‚   â”‚ maps      â”‚   â”‚ direction    â”‚  â”‚ - IBL cubemaps â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ - Light buffersâ”‚            â”‚
â”‚       â”‚             â”‚                â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚       â”‚             â”‚                â”‚                  â”‚                      â”‚
â”‚       â”‚             â”‚ Shadow Map     â”‚ IBL Textures     â”‚                      â”‚
â”‚       â”‚             â”‚ Array          â”‚                  â”‚                      â”‚
â”‚       â”‚             â–¼                â–¼                  â”‚                      â”‚
â”‚       â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚                      â”‚
â”‚       â”‚        â”‚    Unified Bind Groups    â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚       â”‚        â”‚  Group 2: Light Buffers   â”‚                                   â”‚
â”‚       â”‚        â”‚  Group 3: Environment     â”‚                                   â”‚
â”‚       â”‚        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                   â”‚
â”‚       â”‚                    â”‚                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                    â”‚
        â–¼                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                              GPU SHADERS (WGSL)                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  // NEW: Shared light structures                                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚  @group(2) @binding(0) var<uniform> lightCounts: LightCounts;  â”‚            â”‚
â”‚  â”‚  @group(2) @binding(1) var<storage> directionalLights: array<>;â”‚            â”‚
â”‚  â”‚  @group(2) @binding(2) var<storage> pointLights: array<>;      â”‚            â”‚
â”‚  â”‚  @group(2) @binding(3) var<storage> spotLights: array<>;       â”‚            â”‚
â”‚  â”‚  @group(2) @binding(4) var<storage> areaLights: array<>;       â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚    pbr.wgsl      â”‚  â”‚  terrain/cdlod   â”‚  â”‚   water.wgsl     â”‚              â”‚
â”‚  â”‚                  â”‚  â”‚     .wgsl        â”‚  â”‚                  â”‚              â”‚
â”‚  â”‚  for each dir:   â”‚  â”‚  // Same light   â”‚  â”‚  // Same light   â”‚              â”‚
â”‚  â”‚    addDirLight() â”‚  â”‚  // loop logic   â”‚  â”‚  // loop logic   â”‚              â”‚
â”‚  â”‚  for each point: â”‚  â”‚                  â”‚  â”‚                  â”‚              â”‚
â”‚  â”‚    addPointLight â”‚  â”‚                  â”‚  â”‚                  â”‚              â”‚
â”‚  â”‚  for each spot:  â”‚  â”‚                  â”‚  â”‚                  â”‚              â”‚
â”‚  â”‚    addSpotLight()â”‚  â”‚                  â”‚  â”‚                  â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Benefits of New Architecture:**
- Lights are true scene objects - stored in Scene alongside models/primitives
- Unified selection - click a light in Objects Panel like any other object
- Unified serialization - lights save/load with scene
- Direct property mutation - UI updates light properties directly
- Pipeline queries scene - no more passing light params as render options
- Multi-light support - array-based GPU buffers support many lights
- Consistent data flow - same pattern as other scene objects

---

### Detailed Data Flow: UI to Shader

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ USER ACTION: Adjust Sun Azimuth Slider from 45Â° to 90Â°                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. UI EVENT                                                                     â”‚
â”‚    LightPropertiesSection.tsx                                                   â”‚
â”‚    <Slider onChange={(v) => { dirLight.azimuth = v; onUpdate(); }} />          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. SCENE OBJECT UPDATE                                                          â”‚
â”‚    DirectionalLight.azimuth = 90                                                â”‚
â”‚    (property lives in Scene.lights map)                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. RENDER LOOP (every frame)                                                    â”‚
â”‚    GPUForwardPipeline.render(scene, camera, options)                            â”‚
â”‚                                                                                 â”‚
â”‚    const dirLight = scene.getDirectionalLight();                               â”‚
â”‚    if (dirLight) {                                                              â”‚
â”‚      const params = dirLight.getLightParams();                                  â”‚
â”‚      // params.direction = computed from azimuth/elevation                      â”‚
â”‚    }                                                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. LIGHT BUFFER UPDATE                                                          â”‚
â”‚    lightBufferManager.update(scene)                                             â”‚
â”‚                                                                                 â”‚
â”‚    // Pack DirectionalLightData into GPU buffer                                 â”‚
â”‚    data.set([                                                                   â”‚
â”‚      params.direction[0], params.direction[1], params.direction[2],            â”‚
â”‚      params.intensity,                                                          â”‚
â”‚      params.color[0], params.color[1], params.color[2],                        â”‚
â”‚      params.ambient,                                                            â”‚
â”‚      // ...shadow info                                                          â”‚
â”‚    ], offset);                                                                  â”‚
â”‚    ctx.queue.writeBuffer(directionalLightsBuffer, 0, data);                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. IBL UPDATE (if Dynamic IBL enabled)                                          â”‚
â”‚    dynamicSkyIBL.update(encoder, params.direction, params.intensity)            â”‚
â”‚                                                                                 â”‚
â”‚    // Detects sun moved >0.5Â°, triggers re-render of:                          â”‚
â”‚    // - Sky cubemap (256Â³)                                                      â”‚
â”‚    // - Diffuse irradiance (64Â³)                                               â”‚
â”‚    // - Specular prefilter (128Â³ + mips)                                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 6. SHADOW PASS                                                                  â”‚
â”‚    shadowRenderer.renderDirectionalShadow(encoder, dirLight, scene)             â”‚
â”‚                                                                                 â”‚
â”‚    // Light-view matrix computed from dirLight.getDirection()                   â”‚
â”‚    // Renders scene depth to shadow map texture                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 7. GEOMETRY PASS (Terrain, Objects, Water)                                      â”‚
â”‚    renderPass.setBindGroup(2, lightBufferManager.getBindGroup());               â”‚
â”‚    renderPass.setBindGroup(3, sceneEnvironment.getBindGroup());                 â”‚
â”‚                                                                                 â”‚
â”‚    // Each material reads from shared light buffers                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 8. SHADER EXECUTION (pbr.wgsl)                                                  â”‚
â”‚                                                                                 â”‚
â”‚    // Read light data from buffers                                              â”‚
â”‚    let numDir = lightCounts.numDirectional;                                     â”‚
â”‚    for (var i = 0u; i < numDir; i++) {                                         â”‚
â”‚      let light = directionalLights[i];                                          â”‚
â”‚      let L = -light.direction;  // â† New direction from azimuth=90Â°            â”‚
â”‚      let NoL = max(dot(N, L), 0.0);                                            â”‚
â”‚                                                                                 â”‚
â”‚      // Calculate diffuse + specular                                            â”‚
â”‚      let diffuse = albedo * NoL * light.color * light.intensity;               â”‚
â”‚      let specular = calculateSpecularBRDF(N, V, L, roughness, metallic);       â”‚
â”‚                                                                                 â”‚
â”‚      // Sample shadow map                                                       â”‚
â”‚      let shadow = sampleShadow(light.shadowMapIndex, worldPos);                â”‚
â”‚                                                                                 â”‚
â”‚      color += (diffuse + specular) * shadow;                                   â”‚
â”‚    }                                                                            â”‚
â”‚                                                                                 â”‚
â”‚    // IBL ambient (updated cubemaps reflect new sun position)                   â”‚
â”‚    color += sampleIBL(N, V, roughness, metallic, albedo);                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                      â”‚
                                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 9. FINAL OUTPUT                                                                 â”‚
â”‚    Pixel on screen reflects new sun direction (azimuth=90Â°)                    â”‚
â”‚    - Direct lighting angle changed                                              â”‚
â”‚    - Shadows moved                                                              â”‚
â”‚    - Sky colors updated                                                         â”‚
â”‚    - IBL ambient gradually transitions (double-buffered)                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Current State Analysis

### Problem: Inconsistent Architecture

| Object Type | Extends SceneObject? | Managed By |
|-------------|----------------------|------------|
| Primitive (Cube, etc.) | âœ… Yes | `Scene.objects` |
| ModelObject | âœ… Yes | `Scene.objects` |
| GPUTerrainSceneObject | âœ… Yes | `Scene.gpuTerrainObject` |
| OceanSceneObject | âœ… Yes | `Scene.oceanObject` |
| **DirectionalLight** | âœ… Yes | âŒ `LightingManager` (separate) |
| **PointLight** | âœ… Yes | âŒ `LightingManager.pointLights` |
| **HDRLight** | âœ… Yes | âŒ `LightingManager` (separate) |

The `Light` class already extends `SceneObject`, but lights are managed separately by `LightingManager` in the demo layer instead of being part of the Scene.

### Current Data Flow
```
LightingTab (UI)
    â†“ onChange callbacks
EnvironmentPanelBridge
    â†“ context.onLightingChanged()
LightingManager.getLightParams()
    â†“
Viewport.setLightParams(params)
    â†“ stores params
GPUForwardPipeline.render()
    â†“ uses lightParams.direction, sunIntensity, ambient
DynamicSkyIBL + SkyRenderer + ShadowRenderer
```

---

## Target State: Unified Architecture

### Goals
1. **Lights as Scene Objects** - All lights live in `Scene.objects` like other scene content
2. **Unified Serialization** - Lights serialize/deserialize with the scene
3. **Selection Support** - Lights are selectable in the Objects Panel
4. **Scene Graph Integration** - Positioned lights (point, spot) are in the spatial index
5. **Multiple Light Types** - Support for directional, point, spot, area, mesh lights

### Target Data Flow
```
Light Properties (UI) â† Object Panel when light selected
    â†“ direct property updates
Light SceneObject (in Scene.lights)
    â†“ Scene.getDirectionalLight() / getPointLights() etc.
GPUForwardPipeline.render()
    â†“ queries Scene for lights
LightBufferManager â†’ GPU Uniform Buffers
    â†“
Shaders (PBR, Terrain, Water)
```

---

## 1. Light Type Hierarchy

```
SceneObject
    â””â”€â”€ Light (abstract base)
            â”œâ”€â”€ DirectionalLight    (sun, no position, direction only)
            â”œâ”€â”€ PointLight          (position + radius, omnidirectional)
            â”œâ”€â”€ SpotLight           (position + direction + cone angles)
            â”œâ”€â”€ AreaLight           (position + size + direction)
            â”‚      â”œâ”€â”€ RectAreaLight
            â”‚      â””â”€â”€ DiskAreaLight
            â”œâ”€â”€ MeshLight           (emissive mesh, arbitrary shape)
            â””â”€â”€ HDRILight           (environment map, no position)
```

### Existing Light Classes (keep & enhance)
- `Light.ts` - Base class âœ… already extends `SceneObject`
- `DirectionalLight.ts` - Sun light âœ… exists
- `PointLight.ts` - Point light âœ… exists  
- `HDRLight.ts` - HDR environment âœ… exists

### New Light Classes to Create
- `SpotLight.ts` - Cone-shaped light with inner/outer angles
- `AreaLight.ts` - Rectangular/disk area lights (soft shadows)
- `MeshLight.ts` - Emissive geometry (advanced, future)

---

## 2. Light Class Definitions

### 2.1 SpotLight (New)

```typescript
// src/core/sceneObjects/lights/SpotLight.ts

export interface SpotLightParams extends BaseLightParams<'spot'> {
  position: vec3;
  direction: vec3;
  innerConeAngle: number;  // radians, full intensity zone
  outerConeAngle: number;  // radians, falloff to zero
  range: number;           // attenuation distance
}

export interface SerializedSpotLight extends SerializedLight {
  innerConeAngle: number;
  outerConeAngle: number;
  range: number;
}

export class SpotLight extends Light {
  /** Inner cone angle in radians (full intensity) */
  public innerConeAngle: number = Math.PI / 6;   // 30Â°
  
  /** Outer cone angle in radians (falloff to zero) */
  public outerConeAngle: number = Math.PI / 4;   // 45Â°
  
  /** Maximum range/attenuation distance */
  public range: number = 10;
  
  constructor(name: string = 'Spot Light') {
    super('spot', name);
    this.castsShadow = true;
  }
  
  /**
   * Get light direction from object rotation
   */
  getDirection(): vec3 {
    const dir = vec3.create();
    vec3.transformQuat(dir, [0, 0, -1], this.rotationQuat);
    return dir;
  }
  
  getLightParams(): SpotLightParams {
    return {
      ...super.getLightParams(),
      type: 'spot',
      position: vec3.clone(this.position as vec3),
      direction: this.getDirection(),
      innerConeAngle: this.innerConeAngle,
      outerConeAngle: this.outerConeAngle,
      range: this.range,
    };
  }
  
  serialize(): SerializedSpotLight {
    return {
      ...super.serialize(),
      innerConeAngle: this.innerConeAngle,
      outerConeAngle: this.outerConeAngle,
      range: this.range,
    };
  }
  
  deserialize(data: Partial<SerializedSpotLight>): void {
    super.deserialize(data);
    if (data.innerConeAngle !== undefined) this.innerConeAngle = data.innerConeAngle;
    if (data.outerConeAngle !== undefined) this.outerConeAngle = data.outerConeAngle;
    if (data.range !== undefined) this.range = data.range;
  }
}
```

### 2.2 AreaLight (New)

```typescript
// src/core/sceneObjects/lights/AreaLight.ts

export type AreaLightShape = 'rect' | 'disk';

export interface AreaLightParams extends BaseLightParams<'area'> {
  position: vec3;
  direction: vec3;      // normal direction
  width: number;        // or radius for disk
  height: number;       // ignored for disk
  shape: AreaLightShape;
}

export interface SerializedAreaLight extends SerializedLight {
  width: number;
  height: number;
  shape: AreaLightShape;
}

export class AreaLight extends Light {
  /** Width of the light (or radius for disk) */
  public width: number = 1;
  
  /** Height of the light (ignored for disk) */
  public height: number = 1;
  
  /** Shape of the area light */
  public shape: AreaLightShape = 'rect';
  
  constructor(name: string = 'Area Light') {
    super('area', name);
    this.castsShadow = true;
  }
  
  /**
   * Get light direction (normal) from object rotation
   */
  getDirection(): vec3 {
    const dir = vec3.create();
    vec3.transformQuat(dir, [0, -1, 0], this.rotationQuat);
    return dir;
  }
  
  /**
   * Get the area of the light (for power calculations)
   */
  getArea(): number {
    if (this.shape === 'disk') {
      return Math.PI * this.width * this.width;
    }
    return this.width * this.height;
  }
  
  getLightParams(): AreaLightParams {
    return {
      ...super.getLightParams(),
      type: 'area',
      position: vec3.clone(this.position as vec3),
      direction: this.getDirection(),
      width: this.width,
      height: this.height,
      shape: this.shape,
    };
  }
  
  serialize(): SerializedAreaLight {
    return {
      ...super.serialize(),
      width: this.width,
      height: this.height,
      shape: this.shape,
    };
  }
  
  deserialize(data: Partial<SerializedAreaLight>): void {
    super.deserialize(data);
    if (data.width !== undefined) this.width = data.width;
    if (data.height !== undefined) this.height = data.height;
    if (data.shape !== undefined) this.shape = data.shape;
  }
}
```

### 2.3 MeshLight (Future - Advanced)

```typescript
// src/core/sceneObjects/lights/MeshLight.ts

export interface MeshLightParams extends BaseLightParams<'mesh'> {
  meshId: string;  // Reference to an emissive mesh in scene
  power: number;   // Total emitted power (watts)
}

export class MeshLight extends Light {
  /** ID of the linked emissive mesh */
  public linkedMeshId: string | null = null;
  
  /** Total emitted power in watts */
  public power: number = 100;
  
  constructor(name: string = 'Mesh Light') {
    super('mesh', name);
  }
  
  // Implementation requires importance sampling for efficient rendering
  // This is an advanced feature for path tracing / deferred many-light techniques
}
```

---

## 3. Scene Integration

### 3.1 Type Updates

```typescript
// src/core/sceneObjects/lights/types.ts

export type LightType = 'directional' | 'point' | 'spot' | 'area' | 'mesh' | 'hdr';

export type AnyLight = DirectionalLight | PointLight | SpotLight | AreaLight | MeshLight | HDRLight;
```

### 3.2 Scene.ts Changes

```typescript
// Add to Scene.ts

import { 
  Light, 
  DirectionalLight, 
  PointLight, 
  SpotLight, 
  AreaLight,
  HDRLight,
  type LightType,
  type AnyLight
} from './sceneObjects/lights';

export interface SceneCallbacks {
  onSelectionChanged?: (selectedIds: Set<string>) => void;
  onObjectAdded?: (obj: AnySceneObject) => void;
  onObjectRemoved?: (id: string) => void;
  onGroupChanged?: () => void;
  // NEW: Light callbacks
  onLightChanged?: (light: Light) => void;
  onLightAdded?: (light: Light) => void;
  onLightRemoved?: (id: string) => void;
}

export class Scene {
  // Existing maps
  private objects = new Map<string, AnySceneObject>();
  
  // NEW: Specialized light storage for efficient queries
  private lights = new Map<string, Light>();
  private primaryDirectionalLight: DirectionalLight | null = null;
  private environmentLight: HDRLight | null = null;
  
  // ==========================================================================
  // Light Management
  // ==========================================================================
  
  /**
   * Add any light type to the scene
   */
  addLight<T extends Light>(light: T): T {
    // Add to scene graph and objects map
    this.addSceneObject(light);
    
    // Also track in lights map for efficient queries
    this.lights.set(light.id, light);
    
    // Track special lights (first directional becomes primary)
    if (light.lightType === 'directional' && !this.primaryDirectionalLight) {
      this.primaryDirectionalLight = light as unknown as DirectionalLight;
    }
    if (light.lightType === 'hdr') {
      this.environmentLight = light as unknown as HDRLight;
    }
    
    this.callbacks.onLightAdded?.(light);
    return light;
  }
  
  /**
   * Remove a light from the scene
   */
  removeLight(id: string): boolean {
    const light = this.lights.get(id);
    if (!light) return false;
    
    // Clear special references
    if (this.primaryDirectionalLight?.id === id) {
      this.primaryDirectionalLight = null;
      // Find next directional light as primary
      for (const l of this.lights.values()) {
        if (l.lightType === 'directional' && l.id !== id) {
          this.primaryDirectionalLight = l as DirectionalLight;
          break;
        }
      }
    }
    if (this.environmentLight?.id === id) {
      this.environmentLight = null;
    }
    
    this.lights.delete(id);
    this.callbacks.onLightRemoved?.(id);
    
    // Remove from objects map and scene graph
    return this.removeObject(id);
  }
  
  // ---------- Factory Methods ----------
  
  /**
   * Add a directional (sun) light
   */
  addDirectionalLight(name?: string): DirectionalLight {
    const light = new DirectionalLight(name ?? 'Sun');
    return this.addLight(light);
  }
  
  /**
   * Add a point light
   */
  addPointLight(name?: string): PointLight {
    const light = new PointLight(name ?? 'Point Light');
    light.position = [0, 2, 0];  // Default above ground
    return this.addLight(light);
  }
  
  /**
   * Add a spot light
   */
  addSpotLight(name?: string): SpotLight {
    const light = new SpotLight(name ?? 'Spot Light');
    light.position = [0, 3, 0];
    return this.addLight(light);
  }
  
  /**
   * Add an area light
   */
  addAreaLight(shape: AreaLightShape = 'rect', name?: string): AreaLight {
    const light = new AreaLight(name ?? 'Area Light');
    light.shape = shape;
    light.position = [0, 3, 0];
    return this.addLight(light);
  }
  
  /**
   * Add an HDR environment light
   */
  addEnvironmentLight(name?: string): HDRLight {
    const light = new HDRLight(name ?? 'Environment');
    return this.addLight(light);
  }
  
  // ---------- Query Methods ----------
  
  /**
   * Get all lights in the scene
   */
  getAllLights(): Light[] {
    return Array.from(this.lights.values());
  }
  
  /**
   * Get enabled lights only
   */
  getEnabledLights(): Light[] {
    return Array.from(this.lights.values()).filter(l => l.enabled);
  }
  
  /**
   * Get lights by type
   */
  getLightsByType<T extends Light>(type: LightType): T[] {
    return Array.from(this.lights.values())
      .filter(l => l.lightType === type) as T[];
  }
  
  /**
   * Get the primary directional light (sun)
   * Returns the first directional light added, or null
   */
  getDirectionalLight(): DirectionalLight | null {
    return this.primaryDirectionalLight;
  }
  
  /**
   * Get all directional lights
   */
  getDirectionalLights(): DirectionalLight[] {
    return this.getLightsByType<DirectionalLight>('directional');
  }
  
  /**
   * Get environment/IBL light
   */
  getEnvironmentLight(): HDRLight | null {
    return this.environmentLight;
  }
  
  /**
   * Get point lights
   */
  getPointLights(): PointLight[] {
    return this.getLightsByType<PointLight>('point');
  }
  
  /**
   * Get spot lights
   */
  getSpotLights(): SpotLight[] {
    return this.getLightsByType<SpotLight>('spot');
  }
  
  /**
   * Get area lights
   */
  getAreaLights(): AreaLight[] {
    return this.getLightsByType<AreaLight>('area');
  }
  
  /**
   * Get all shadow-casting lights
   */
  getShadowCastingLights(): Light[] {
    return Array.from(this.lights.values()).filter(l => l.enabled && l.castsShadow);
  }
  
  /**
   * Get light count
   */
  getLightCount(): number {
    return this.lights.size;
  }
  
  /**
   * Check if a light exists
   */
  hasLight(id: string): boolean {
    return this.lights.has(id);
  }
}
```

### 3.3 Update removeObject()

```typescript
// In Scene.ts, update removeObject to handle lights

removeObject(id: string): boolean {
  const obj = this.objects.get(id);
  if (!obj) return false;
  
  // Remove from group first
  this.removeFromGroup(id);
  
  // Clear special references
  if (this.gpuTerrainObject?.id === id) {
    this.gpuTerrainObject = null;
  }
  if (this.oceanObject?.id === id) {
    this.oceanObject = null;
  }
  
  // NEW: Handle light removal
  if (this.lights.has(id)) {
    this.removeLight(id);
  }
  
  // Destroy renderer and remove
  obj.destroy();
  this.objects.delete(id);
  this.sceneGraph.remove(id);
  
  // Remove from selection
  this.selectedIds.delete(id);
  
  this.callbacks.onObjectRemoved?.(id);
  
  return true;
}
```

---

## 4. GPU Pipeline Changes

### 4.1 Light Uniform Buffer Structures

```wgsl
// src/core/gpu/shaders/common/lights.wgsl

struct DirectionalLightData {
  direction: vec3f,
  intensity: f32,
  color: vec3f,
  ambient: f32,
  shadowEnabled: u32,
  shadowMapIndex: u32,  // Index into shadow map array
  _pad: vec2u,
};

struct PointLightData {
  position: vec3f,
  range: f32,
  color: vec3f,
  intensity: f32,
};

struct SpotLightData {
  position: vec3f,
  range: f32,
  direction: vec3f,
  intensity: f32,
  color: vec3f,
  innerCos: f32,  // cos(innerConeAngle)
  outerCos: f32,  // cos(outerConeAngle)
  shadowEnabled: u32,
  shadowMapIndex: u32,
  _pad: f32,
};

struct AreaLightData {
  position: vec3f,
  width: f32,
  direction: vec3f,
  height: f32,
  color: vec3f,
  intensity: f32,
  // For LTC (Linearly Transformed Cosines) shading
  right: vec3f,  // Local X axis
  _pad: f32,
  up: vec3f,     // Local Y axis  
  shape: u32,    // 0 = rect, 1 = disk
};

struct LightCounts {
  numDirectional: u32,
  numPoint: u32,
  numSpot: u32,
  numArea: u32,
};

// Bind group 2: Lights
@group(2) @binding(0) var<uniform> lightCounts: LightCounts;
@group(2) @binding(1) var<storage, read> directionalLights: array<DirectionalLightData>;
@group(2) @binding(2) var<storage, read> pointLights: array<PointLightData>;
@group(2) @binding(3) var<storage, read> spotLights: array<SpotLightData>;
@group(2) @binding(4) var<storage, read> areaLights: array<AreaLightData>;
```

### 4.2 LightBufferManager

```typescript
// src/core/gpu/renderers/LightBufferManager.ts

export interface LightBufferManagerOptions {
  maxDirectionalLights?: number;  // Default: 4
  maxPointLights?: number;        // Default: 64
  maxSpotLights?: number;         // Default: 32
  maxAreaLights?: number;         // Default: 16
}

export class LightBufferManager {
  private ctx: GPUContext;
  
  private lightCountsBuffer: GPUBuffer;
  private directionalLightsBuffer: GPUBuffer;
  private pointLightsBuffer: GPUBuffer;
  private spotLightsBuffer: GPUBuffer;
  private areaLightsBuffer: GPUBuffer;
  
  private bindGroupLayout: GPUBindGroupLayout;
  private bindGroup: GPUBindGroup;
  
  constructor(ctx: GPUContext, options: LightBufferManagerOptions = {}) {
    const maxDirectional = options.maxDirectionalLights ?? 4;
    const maxPoint = options.maxPointLights ?? 64;
    const maxSpot = options.maxSpotLights ?? 32;
    const maxArea = options.maxAreaLights ?? 16;
    
    // Create buffers
    this.lightCountsBuffer = ctx.device.createBuffer({
      label: 'light-counts',
      size: 16, // 4 u32s
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
    });
    
    // DirectionalLightData: 48 bytes each
    this.directionalLightsBuffer = ctx.device.createBuffer({
      label: 'directional-lights',
      size: maxDirectional * 48,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });
    
    // PointLightData: 32 bytes each
    this.pointLightsBuffer = ctx.device.createBuffer({
      label: 'point-lights',
      size: maxPoint * 32,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });
    
    // SpotLightData: 64 bytes each
    this.spotLightsBuffer = ctx.device.createBuffer({
      label: 'spot-lights',
      size: maxSpot * 64,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });
    
    // AreaLightData: 80 bytes each
    this.areaLightsBuffer = ctx.device.createBuffer({
      label: 'area-lights',
      size: maxArea * 80,
      usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
    });
    
    // Create bind group layout and bind group
    this.createBindGroup();
  }
  
  /**
   * Update light buffers from scene
   */
  update(scene: Scene): void {
    const directional = scene.getDirectionalLights().filter(l => l.enabled);
    const points = scene.getPointLights().filter(l => l.enabled);
    const spots = scene.getSpotLights().filter(l => l.enabled);
    const areas = scene.getAreaLights().filter(l => l.enabled);
    
    // Update counts
    const counts = new Uint32Array([
      directional.length,
      points.length,
      spots.length,
      areas.length,
    ]);
    this.ctx.queue.writeBuffer(this.lightCountsBuffer, 0, counts);
    
    // Update directional lights
    if (directional.length > 0) {
      const data = new Float32Array(directional.length * 12); // 48 bytes / 4
      for (let i = 0; i < directional.length; i++) {
        const params = directional[i].getLightParams();
        const offset = i * 12;
        data.set([
          params.direction[0], params.direction[1], params.direction[2], params.intensity,
          params.color[0], params.color[1], params.color[2], params.ambient,
        ], offset);
        // Shadow info in remaining 4 floats (as uint32 view)
        const uintView = new Uint32Array(data.buffer, (offset + 8) * 4, 4);
        uintView[0] = params.castsShadow ? 1 : 0;
        uintView[1] = 0; // shadowMapIndex
      }
      this.ctx.queue.writeBuffer(this.directionalLightsBuffer, 0, data);
    }
    
    // Update point lights
    if (points.length > 0) {
      const data = new Float32Array(points.length * 8); // 32 bytes / 4
      for (let i = 0; i < points.length; i++) {
        const params = points[i].getLightParams();
        const offset = i * 8;
        data.set([
          params.position[0], params.position[1], params.position[2], params.range,
          params.color[0], params.color[1], params.color[2], params.intensity,
        ], offset);
      }
      this.ctx.queue.writeBuffer(this.pointLightsBuffer, 0, data);
    }
    
    // Similar for spot and area lights...
  }
  
  getBindGroupLayout(): GPUBindGroupLayout {
    return this.bindGroupLayout;
  }
  
  getBindGroup(): GPUBindGroup {
    return this.bindGroup;
  }
  
  destroy(): void {
    this.lightCountsBuffer.destroy();
    this.directionalLightsBuffer.destroy();
    this.pointLightsBuffer.destroy();
    this.spotLightsBuffer.destroy();
    this.areaLightsBuffer.destroy();
  }
}
```

### 4.3 GPUForwardPipeline Changes

```typescript
// In GPUForwardPipeline.ts

export class GPUForwardPipeline {
  // NEW: Light buffer manager
  private lightBufferManager: LightBufferManager;
  
  constructor(ctx: GPUContext, options: GPUForwardPipelineOptions) {
    // ... existing initialization
    
    // NEW: Create light buffer manager
    this.lightBufferManager = new LightBufferManager(ctx);
  }
  
  render(scene: Scene | null, camera: GPUCamera, options: RenderOptions = {}): void {
    if (!scene) return;
    
    // ... existing setup
    
    // NEW: Update light buffers from scene (replaces options.lightDirection etc.)
    this.lightBufferManager.update(scene);
    
    // Get primary light for IBL/shadows
    const dirLight = scene.getDirectionalLight();
    const envLight = scene.getEnvironmentLight();
    
    // Update IBL based on lighting setup
    if (envLight && envLight.enabled) {
      // Use HDR environment map
      this.sceneEnvironment.setIBL(envLight.getIBLResources());
    } else if (dirLight && options.dynamicIBL !== false) {
      // Use procedural sky IBL
      const params = dirLight.getLightParams();
      this.dynamicSkyIBL.update(
        encoder, 
        [params.direction[0], params.direction[1], params.direction[2]], 
        params.intensity, 
        deltaTime
      );
      if (this.dynamicSkyIBL.isReady()) {
        this.sceneEnvironment.setIBL(this.dynamicSkyIBL.getIBLTextures());
      }
    }
    
    // Shadow pass for shadow-casting lights
    const shadowLights = scene.getShadowCastingLights();
    for (const light of shadowLights) {
      if (light.lightType === 'directional') {
        this.shadowRenderer.renderDirectionalShadow(
          encoder, 
          light as DirectionalLight, 
          scene
        );
      }
      // Future: point light cube shadows, spot light shadows
    }
    
    // ... rest of rendering
  }
}
```

---

## 5. Serialization Updates

### 5.1 SerializedScene Changes

```typescript
// In Scene.ts

export interface SerializedScene {
  objects: Array<SerializedPrimitiveObject | SerializedModelObject | SerializedTerrainObject>;
  lights: SerializedLight[];  // NEW: Lights serialized separately
  groups: SerializedGroup[];
}
```

### 5.2 Scene.serialize() Changes

```typescript
serialize(): SerializedScene {
  // ... existing object serialization
  
  // NEW: Serialize lights
  const serializedLights: SerializedLight[] = [];
  for (const light of this.lights.values()) {
    serializedLights.push(light.serialize());
  }
  
  return {
    objects: serializedObjects,
    lights: serializedLights,
    groups: serializedGroups,
  };
}
```

### 5.3 Scene.deserialize() Changes

```typescript
async deserialize(data: SerializedScene | null): Promise<void> {
  this.clear();
  if (!data) return;
  
  // ... existing object deserialization
  
  // NEW: Deserialize lights
  if (data.lights) {
    for (const lightData of data.lights) {
      let light: Light | null = null;
      
      switch (lightData.type) {
        case 'directional':
          light = this.addDirectionalLight(lightData.name);
          break;
        case 'point':
          light = this.addPointLight(lightData.name);
          break;
        case 'spot':
          light = this.addSpotLight(lightData.name);
          break;
        case 'area':
          light = this.addAreaLight(
            (lightData as SerializedAreaLight).shape, 
            lightData.name
          );
          break;
        case 'hdr':
          light = this.addEnvironmentLight(lightData.name);
          break;
      }
      
      if (light) {
        light.deserialize(lightData);
        this.updateObjectTransform(light.id);
      }
    }
  }
  
  // ... rest of deserialization
}
```

---

## 6. UI Changes

### 6.1 Objects Panel

Show lights in the scene hierarchy with appropriate icons:

```tsx
// Light icon mapping
const LIGHT_ICONS: Record<LightType, string> = {
  directional: 'â˜€ï¸',  // Sun
  point: 'ğŸ’¡',        // Bulb
  spot: 'ğŸ”¦',         // Flashlight
  area: 'â–¢',          // Rectangle
  mesh: 'âœ¨',         // Sparkles
  hdr: 'ğŸŒ„',          // Landscape (environment)
};

// In ObjectsPanel, detect light objects
if (obj.objectType === 'light') {
  const light = obj as Light;
  icon = LIGHT_ICONS[light.lightType];
}
```

### 6.2 Object Panel - Light Properties

When a light is selected, show light-specific properties:

```tsx
// LightPropertiesSection.tsx

interface LightPropertiesSectionProps {
  light: Light;
  onUpdate: () => void;
}

export function LightPropertiesSection({ light, onUpdate }: LightPropertiesSectionProps) {
  const commonProps = (
    <>
      <Checkbox
        label="Enabled"
        checked={light.enabled}
        onChange={(v) => { light.enabled = v; onUpdate(); }}
      />
      <Slider
        label="Intensity"
        value={light.intensity}
        min={0} max={10} step={0.1}
        onChange={(v) => { light.intensity = v; onUpdate(); }}
      />
      <ColorPicker
        label="Color"
        value={light.color}
        onChange={(v) => { light.setColorArray(v); onUpdate(); }}
      />
      <Checkbox
        label="Cast Shadows"
        checked={light.castsShadow}
        onChange={(v) => { light.castsShadow = v; onUpdate(); }}
      />
    </>
  );
  
  // Type-specific properties
  switch (light.lightType) {
    case 'directional':
      const dirLight = light as DirectionalLight;
      return (
        <Section title="Directional Light">
          {commonProps}
          <Slider
            label="Azimuth"
            value={dirLight.azimuth} min={0} max={360} step={1}
            format={(v) => `${v}Â°`}
            onChange={(v) => { dirLight.azimuth = v; onUpdate(); }}
          />
          <Slider
            label="Elevation"
            value={dirLight.elevation} min={-90} max={90} step={1}
            format={(v) => `${v}Â°`}
            onChange={(v) => { dirLight.elevation = v; onUpdate(); }}
          />
          <Slider
            label="Ambient"
            value={dirLight.ambientIntensity} min={0} max={2} step={0.1}
            onChange={(v) => { dirLight.ambientIntensity = v; onUpdate(); }}
          />
        </Section>
      );
      
    case 'point':
      const pointLight = light as PointLight;
      return (
        <Section title="Point Light">
          {commonProps}
          <Slider
            label="Range"
            value={pointLight.range} min={0.1} max={100} step={0.5}
            onChange={(v) => { pointLight.range = v; onUpdate(); }}
          />
        </Section>
      );
      
    case 'spot':
      const spotLight = light as SpotLight;
      return (
        <Section title="Spot Light">
          {commonProps}
          <Slider
            label="Range"
            value={spotLight.range} min={0.1} max={100} step={0.5}
            onChange={(v) => { spotLight.range = v; onUpdate(); }}
          />
          <Slider
            label="Inner Angle"
            value={spotLight.innerConeAngle * 180 / Math.PI}
            min={1} max={89} step={1}
            format={(v) => `${v}Â°`}
            onChange={(v) => { spotLight.innerConeAngle = v * Math.PI / 180; onUpdate(); }}
          />
          <Slider
            label="Outer Angle"
            value={spotLight.outerConeAngle * 180 / Math.PI}
            min={1} max={90} step={1}
            format={(v) => `${v}Â°`}
            onChange={(v) => { spotLight.outerConeAngle = v * Math.PI / 180; onUpdate(); }}
          />
        </Section>
      );
      
    case 'area':
      const areaLight = light as AreaLight;
      return (
        <Section title="Area Light">
          {commonProps}
          <Dropdown
            label="Shape"
            value={areaLight.shape}
            options={['rect', 'disk']}
            onChange={(v) => { areaLight.shape = v; onUpdate(); }}
          />
          <Slider
            label="Width"
            value={areaLight.width} min={0.1} max={10} step={0.1}
            onChange={(v) => { areaLight.width = v; onUpdate(); }}
          />
          {areaLight.shape === 'rect' && (
            <Slider
              label="Height"
              value={areaLight.height} min={0.1} max={10} step={0.1}
              onChange={(v) => { areaLight.height = v; onUpdate(); }}
            />
          )}
        </Section>
      );
      
    default:
      return <Section title="Light">{commonProps}</Section>;
  }
}
```

### 6.3 Add Light Menu

```tsx
// In MenuBar.tsx or Add menu

const lightMenuItems = [
  { label: 'â˜€ï¸ Directional Light', action: () => scene.addDirectionalLight() },
  { label: 'ğŸ’¡ Point Light', action: () => scene.addPointLight() },
  { label: 'ğŸ”¦ Spot Light', action: () => scene.addSpotLight() },
  { label: 'â–¢ Area Light (Rect)', action: () => scene.addAreaLight('rect') },
  { label: 'â—¯ Area Light (Disk)', action: () => scene.addAreaLight('disk') },
  { label: 'ğŸŒ„ Environment (HDR)', action: () => scene.addEnvironmentLight() },
];

// Render as submenu under Add â†’ Light
```

---

## 7. Migration Phases

### Phase 1: Scene Light Management (Foundation)
**Goal**: Add light storage and query methods to Scene without breaking existing code.

- [ ] Add `lights` map to `Scene.ts`
- [ ] Add light factory methods (`addDirectionalLight()`, `addPointLight()`, etc.)
- [ ] Add light query methods (`getDirectionalLight()`, `getPointLights()`, etc.)
- [ ] Add `onLightAdded`, `onLightRemoved`, `onLightChanged` callbacks
- [ ] Update `removeObject()` to handle light cleanup
- [ ] Update `clear()` to clear lights map

**Compatibility**: `LightingManager` still works, Scene methods are additive.

### Phase 2: New Light Types
**Goal**: Implement SpotLight and AreaLight classes.

- [ ] Create `src/core/sceneObjects/lights/SpotLight.ts`
- [ ] Create `src/core/sceneObjects/lights/AreaLight.ts`
- [ ] Update `src/core/sceneObjects/lights/types.ts` with new types
- [ ] Update `src/core/sceneObjects/lights/index.ts` exports
- [ ] Add unit tests for new light classes

### Phase 3: GPU Pipeline Integration
**Goal**: Pipeline queries Scene for lights instead of receiving params via options.

- [ ] Create `src/core/gpu/renderers/LightBufferManager.ts`
- [ ] Create `src/core/gpu/shaders/common/lights.wgsl`
- [ ] Update `GPUForwardPipeline` to use `LightBufferManager`
- [ ] Update `RenderContext` to include light references
- [ ] Update PBR shader for multi-light support (point, spot)
- [ ] Add point/spot light attenuation calculations to shaders

### Phase 4: UI Migration
**Goal**: Integrate lights into the scene hierarchy and property panels.

- [ ] Update Objects Panel to show lights with appropriate icons
- [ ] Create `LightPropertiesSection` component for Object Panel
- [ ] Add "Add Light" submenu to MenuBar
- [ ] Remove or repurpose Environment Panel's Lighting tab
- [ ] Update gizmo to work with light rotation/position

### Phase 5: Deprecation
**Goal**: Remove `LightingManager` and old data flow.

- [ ] Mark `LightingManager` as `@deprecated`
- [ ] Update all demo code to use Scene light APIs
- [ ] Remove `Viewport.setLightParams()` method
- [ ] Remove `options.lightDirection` from `RenderOptions`
- [ ] Remove `LightingManager` class and file
- [ ] Update documentation

---

## 8. Light Count Limits & Scalability

### Forward Rendering Light Limits

The initial implementation uses **naive forward rendering** with storage buffer arrays. Here's what to expect:

| Approach | Max Visible Lights | Notes |
|----------|-------------------|-------|
| Naive Forward | ~8-16 | Every pixel evaluates ALL lights. O(pixels Ã— lights) |
| Forward + CPU Frustum Culling | ~64-128 | Only visible lights uploaded, still per-pixel cost |
| Forward+ (Tiled) | ~500-1000 | GPU compute culls lights per screen tile |
| Clustered Forward | ~4000+ | 3D clusters for tight per-pixel light lists |

### Why 64-128 Lights is the Initial Target

**Fragment Shader Cost**: At 1080p (2M pixels), evaluating 64 lights = **128 million light calculations per frame**. Each light adds:
- 1 dot product (NÂ·L)
- Distance attenuation (point/spot)
- Cone falloff (spot)
- Shadow map sample (if enabled)

**Practical Limit**: Without tiled culling, ~64 point/spot + ~4 directional is reasonable for 60fps on modern GPUs.

### Buffer Capacity (Not the Bottleneck)

WebGPU storage buffers are generous:
```
maxStorageBufferBindingSize: 128MB minimum (often 1GB+)

PointLightData (32 bytes) â†’ 128MB / 32B = 4 million lights per buffer
SpotLightData (64 bytes)  â†’ 128MB / 64B = 2 million lights per buffer
```

**GPU memory is NOT the limit** â€” shader ALU cost is.

### Scaling Beyond 128 Lights: Forward+ (Phase 6)

For game-level light counts (hundreds/thousands), add **Forward+ Tiled Shading**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        FORWARD+ TILED LIGHT CULLING                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  1. DEPTH PRE-PASS (existing)                                           â”‚   â”‚
â”‚  â”‚     Render scene depth only                                             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                       â”‚                                         â”‚
â”‚                                       â–¼                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  2. TILE DEPTH BOUNDS (compute shader - NEW)                            â”‚   â”‚
â”‚  â”‚     For each 16Ã—16 pixel tile:                                          â”‚   â”‚
â”‚  â”‚       - Find min/max depth in tile                                      â”‚   â”‚
â”‚  â”‚       - Create tile frustum from camera + depth bounds                  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                       â”‚                                         â”‚
â”‚                                       â–¼                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  3. LIGHT CULLING (compute shader - NEW)                                â”‚   â”‚
â”‚  â”‚     For each tile:                                                      â”‚   â”‚
â”‚  â”‚       For each light:                                                   â”‚   â”‚
â”‚  â”‚         - Test light bounding sphere vs tile frustum                    â”‚   â”‚
â”‚  â”‚         - If intersects: append light index to tile's light list        â”‚   â”‚
â”‚  â”‚     Output: tileData[tileIdx] = { offset, count, lightIndices[] }       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                       â”‚                                         â”‚
â”‚                                       â–¼                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  4. SHADING PASS (fragment shader - MODIFIED)                           â”‚   â”‚
â”‚  â”‚     let tileIdx = getTileIndex(fragCoord);                              â”‚   â”‚
â”‚  â”‚     let tileInfo = tileLightData[tileIdx];                              â”‚   â”‚
â”‚  â”‚     for (i = 0; i < tileInfo.count; i++) {                              â”‚   â”‚
â”‚  â”‚       let lightIdx = tileInfo.lightIndices[i];                          â”‚   â”‚
â”‚  â”‚       // Only evaluate lights that affect THIS tile                     â”‚   â”‚
â”‚  â”‚       color += evaluateLight(lightIdx, ...);                            â”‚   â”‚
â”‚  â”‚     }                                                                   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Forward+ Benefits**:
- Typical tile has 4-20 lights even with 1000+ in scene
- Much better GPU utilization than naive forward
- Works great with WebGPU compute shaders

### Phase 6 Tasks (Future - Forward+ Tiled Shading)

- [ ] Create `src/core/gpu/pipeline/TileLightCulling.ts`
- [ ] Create `src/core/gpu/shaders/lighting/tile-depth-bounds.wgsl`
- [ ] Create `src/core/gpu/shaders/lighting/light-culling.wgsl`
- [ ] Create tile light list storage buffers
- [ ] Modify PBR/terrain/water shaders to read from tile light lists
- [ ] Add tile debugging visualization
- [ ] Benchmark and tune tile size (16Ã—16 vs 32Ã—32)

### Phase 7 (Advanced - Clustered Forward)

For **massive light counts** (4000+), add depth clustering:

- [ ] Replace 2D tiles with 3D clusters (X Ã— Y Ã— Depth slices)
- [ ] Exponential depth slicing for better near-plane resolution
- [ ] Per-cluster light assignment
- [ ] Useful for: night city scenes, dense interior lighting

### Scalability Summary

| Phase | Max Lights | Technique | Implementation |
|-------|------------|-----------|----------------|
| 1-5 | ~64-128 | Forward + CPU culling | âœ… Migration plan |
| 6 | ~500-1000 | Forward+ Tiled | ğŸ”® Compute shader |
| 7 | ~4000+ | Clustered Forward | ğŸ”®ğŸ”® 3D data structure |

For a **scene builder / 3D editor**, 64-128 lights is plenty. For **games** with many dynamic lights, Phase 6 (Forward+) is the recommended upgrade path.

---

## 9. Future Enhancements

### 8.1 Shadow Mapping Expansion

| Light Type | Shadow Map Type | Implementation |
|------------|-----------------|----------------|
| Directional | 2D (CSM optional) | âœ… Exists |
| Point | Cube map (6 faces) | ğŸ”® Future |
| Spot | 2D perspective | ğŸ”® Future |
| Area | VSM/PCSS approximation | ğŸ”® Future |

**Point Light Shadows**:
```wgsl
// Sample from cube shadow map
fn samplePointShadow(lightIndex: u32, worldPos: vec3f) -> f32 {
  let lightPos = pointLights[lightIndex].position;
  let toLight = worldPos - lightPos;
  let depth = length(toLight);
  let shadowDepth = textureSampleCompare(
    pointShadowMaps, shadowSampler, 
    normalize(toLight), lightIndex, depth
  );
  return shadowDepth;
}
```

### 8.2 Area Light Soft Shadows

Using Linearly Transformed Cosines (LTC) for physically-based area light shading:
- Pre-computed LTC matrices stored in texture
- Handles polygonal (rect) area lights accurately
- Provides soft shadow approximation via analytic integration

### 8.3 Mesh Lights (Path Tracing Support)

For advanced rendering:
- Link `MeshLight` to any emissive mesh in the scene
- Build acceleration structure (BVH) over light geometry
- Importance sample light surface for efficient path tracing
- Useful for neon signs, glowing objects, screens

### 8.4 Light Probes

For indirect lighting in outdoor/indoor scenes:
- Place light probes at key positions
- Capture local IBL (irradiance + specular) per probe
- Interpolate between probes based on object position
- Enables realistic indirect lighting without full GI

---

## 9. Testing Checklist

### Unit Tests
- [ ] `DirectionalLight.getLightParams()` returns correct direction
- [ ] `PointLight.getLightParams()` returns position and range
- [ ] `SpotLight.getLightParams()` returns correct cone angles
- [ ] `AreaLight.getArea()` calculates correctly for rect/disk
- [ ] `Scene.addLight()` adds to both `objects` and `lights` maps
- [ ] `Scene.removeLight()` cleans up all references
- [ ] `Scene.getDirectionalLight()` returns primary sun

### Integration Tests
- [ ] Lights appear in Objects Panel hierarchy
- [ ] Selecting a light shows properties in Object Panel
- [ ] Deleting a light removes it from scene and rendering
- [ ] Scene serialization includes lights
- [ ] Scene deserialization restores lights correctly
- [ ] Dynamic IBL updates when directional light changes

### Visual Tests
- [ ] Directional light illuminates scene correctly
- [ ] Point light attenuation looks correct
- [ ] Spot light cone falloff renders properly
- [ ] Multiple lights combine correctly (additive)
- [ ] Shadows render for shadow-casting lights

---

## 10. References

- **Three.js Light System**: https://threejs.org/docs/#api/en/lights/Light
- **Unity Lights**: https://docs.unity3d.com/Manual/Lighting.html
- **Filament Lights**: https://google.github.io/filament/Filament.html#lighting
- **LTC Area Lights**: https://eheitzresearch.wordpress.com/415-2/
- **WebGPU Best Practices**: https://toji.dev/webgpu-best-practices/
